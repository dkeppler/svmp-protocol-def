// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: svmp.proto

#ifndef PROTOBUF_svmp_2eproto__INCLUDED
#define PROTOBUF_svmp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace svmp {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_svmp_2eproto();
void protobuf_AssignDesc_svmp_2eproto();
void protobuf_ShutdownFile_svmp_2eproto();

class Request;
class Response;
class Intent;
class Intent_Tuple;
class Notification;
class TouchEvent;
class TouchEvent_PointerCoords;
class ScreenInfo;
class SensorEvent;
class SensorSubscribe;
class SensorUnsubscribe;
class LocationProviderInfo;
class LocationProviderStatus;
class LocationProviderStatus_Tuple;
class LocationProviderEnabled;
class LocationUpdate;
class LocationRequest;
class LocationSubscribe;
class LocationUnsubscribe;
class LocationResponse;
class Authentication;
class VideoRequest;
class WebRTCMessage;

enum Request_RequestType {
  Request_RequestType_USERAUTH = 0,
  Request_RequestType_VIDEO_PARAMS = 1,
  Request_RequestType_TOUCHEVENT = 2,
  Request_RequestType_SENSOREVENT = 3,
  Request_RequestType_LOCATION = 4,
  Request_RequestType_INTENT = 5,
  Request_RequestType_SCREENINFO = 6,
  Request_RequestType_VIDEO_START = 7,
  Request_RequestType_VIDEO_STOP = 8,
  Request_RequestType_WEBRTC = 9
};
bool Request_RequestType_IsValid(int value);
const Request_RequestType Request_RequestType_RequestType_MIN = Request_RequestType_USERAUTH;
const Request_RequestType Request_RequestType_RequestType_MAX = Request_RequestType_WEBRTC;
const int Request_RequestType_RequestType_ARRAYSIZE = Request_RequestType_RequestType_MAX + 1;

enum Response_ResponseType {
  Response_ResponseType_ERROR = 0,
  Response_ResponseType_AUTHOK = 1,
  Response_ResponseType_VMREADY = 2,
  Response_ResponseType_SCREENINFO = 3,
  Response_ResponseType_WEBRTC = 4,
  Response_ResponseType_INTENT = 5,
  Response_ResponseType_NOTIFICATION = 6,
  Response_ResponseType_LOCATION = 7,
  Response_ResponseType_VIDEOSTART = 8,
  Response_ResponseType_VIDEOSTOP = 9,
  Response_ResponseType_VIDEOPAUSE = 10
};
bool Response_ResponseType_IsValid(int value);
const Response_ResponseType Response_ResponseType_ResponseType_MIN = Response_ResponseType_ERROR;
const Response_ResponseType Response_ResponseType_ResponseType_MAX = Response_ResponseType_VIDEOPAUSE;
const int Response_ResponseType_ResponseType_ARRAYSIZE = Response_ResponseType_ResponseType_MAX + 1;

enum LocationRequest_LocationRequestType {
  LocationRequest_LocationRequestType_PROVIDERINFO = 1,
  LocationRequest_LocationRequestType_PROVIDERSTATUS = 2,
  LocationRequest_LocationRequestType_PROVIDERENABLED = 3,
  LocationRequest_LocationRequestType_LOCATIONUPDATE = 4
};
bool LocationRequest_LocationRequestType_IsValid(int value);
const LocationRequest_LocationRequestType LocationRequest_LocationRequestType_LocationRequestType_MIN = LocationRequest_LocationRequestType_PROVIDERINFO;
const LocationRequest_LocationRequestType LocationRequest_LocationRequestType_LocationRequestType_MAX = LocationRequest_LocationRequestType_LOCATIONUPDATE;
const int LocationRequest_LocationRequestType_LocationRequestType_ARRAYSIZE = LocationRequest_LocationRequestType_LocationRequestType_MAX + 1;

enum LocationSubscribe_LocationSubscribeType {
  LocationSubscribe_LocationSubscribeType_SINGLE_UPDATE = 1,
  LocationSubscribe_LocationSubscribeType_MULTIPLE_UPDATES = 2
};
bool LocationSubscribe_LocationSubscribeType_IsValid(int value);
const LocationSubscribe_LocationSubscribeType LocationSubscribe_LocationSubscribeType_LocationSubscribeType_MIN = LocationSubscribe_LocationSubscribeType_SINGLE_UPDATE;
const LocationSubscribe_LocationSubscribeType LocationSubscribe_LocationSubscribeType_LocationSubscribeType_MAX = LocationSubscribe_LocationSubscribeType_MULTIPLE_UPDATES;
const int LocationSubscribe_LocationSubscribeType_LocationSubscribeType_ARRAYSIZE = LocationSubscribe_LocationSubscribeType_LocationSubscribeType_MAX + 1;

enum LocationResponse_LocationResponseType {
  LocationResponse_LocationResponseType_SUBSCRIBE = 1,
  LocationResponse_LocationResponseType_UNSUBSCRIBE = 2
};
bool LocationResponse_LocationResponseType_IsValid(int value);
const LocationResponse_LocationResponseType LocationResponse_LocationResponseType_LocationResponseType_MIN = LocationResponse_LocationResponseType_SUBSCRIBE;
const LocationResponse_LocationResponseType LocationResponse_LocationResponseType_LocationResponseType_MAX = LocationResponse_LocationResponseType_UNSUBSCRIBE;
const int LocationResponse_LocationResponseType_LocationResponseType_ARRAYSIZE = LocationResponse_LocationResponseType_LocationResponseType_MAX + 1;

enum WebRTCMessage_WebRTCType {
  WebRTCMessage_WebRTCType_OFFER = 1,
  WebRTCMessage_WebRTCType_ANSWER = 2,
  WebRTCMessage_WebRTCType_CANDIDATE = 3,
  WebRTCMessage_WebRTCType_BYE = 4
};
bool WebRTCMessage_WebRTCType_IsValid(int value);
const WebRTCMessage_WebRTCType WebRTCMessage_WebRTCType_WebRTCType_MIN = WebRTCMessage_WebRTCType_OFFER;
const WebRTCMessage_WebRTCType WebRTCMessage_WebRTCType_WebRTCType_MAX = WebRTCMessage_WebRTCType_BYE;
const int WebRTCMessage_WebRTCType_WebRTCType_ARRAYSIZE = WebRTCMessage_WebRTCType_WebRTCType_MAX + 1;

enum IntentAction {
  ACTION_VIEW = 1,
  ACTION_DIAL = 2
};
bool IntentAction_IsValid(int value);
const IntentAction IntentAction_MIN = ACTION_VIEW;
const IntentAction IntentAction_MAX = ACTION_DIAL;
const int IntentAction_ARRAYSIZE = IntentAction_MAX + 1;

enum SensorType {
  ACCELEROMETER = 1,
  MAGNETIC_FIELD = 2,
  ORIENTATION = 3,
  GYROSCOPE = 4,
  LIGHT = 5,
  PRESSURE = 6,
  TEMPERATURE = 7,
  PROXIMITY = 8,
  GRAVITY = 9,
  LINEAR_ACCELERATION = 10,
  ROTATION_VECTOR = 11,
  RELATIVE_HUMIDITY = 12,
  AMBIENT_TEMPERATURE = 13
};
bool SensorType_IsValid(int value);
const SensorType SensorType_MIN = ACCELEROMETER;
const SensorType SensorType_MAX = AMBIENT_TEMPERATURE;
const int SensorType_ARRAYSIZE = SensorType_MAX + 1;

// ===================================================================

class Request : public ::google::protobuf::MessageLite {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Request_RequestType RequestType;
  static const RequestType USERAUTH = Request_RequestType_USERAUTH;
  static const RequestType VIDEO_PARAMS = Request_RequestType_VIDEO_PARAMS;
  static const RequestType TOUCHEVENT = Request_RequestType_TOUCHEVENT;
  static const RequestType SENSOREVENT = Request_RequestType_SENSOREVENT;
  static const RequestType LOCATION = Request_RequestType_LOCATION;
  static const RequestType INTENT = Request_RequestType_INTENT;
  static const RequestType SCREENINFO = Request_RequestType_SCREENINFO;
  static const RequestType VIDEO_START = Request_RequestType_VIDEO_START;
  static const RequestType VIDEO_STOP = Request_RequestType_VIDEO_STOP;
  static const RequestType WEBRTC = Request_RequestType_WEBRTC;
  static inline bool RequestType_IsValid(int value) {
    return Request_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    Request_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    Request_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    Request_RequestType_RequestType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .svmp.Request.RequestType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::Request_RequestType type() const;
  inline void set_type(::svmp::Request_RequestType value);

  // optional .svmp.Authentication authentication = 2;
  inline bool has_authentication() const;
  inline void clear_authentication();
  static const int kAuthenticationFieldNumber = 2;
  inline const ::svmp::Authentication& authentication() const;
  inline ::svmp::Authentication* mutable_authentication();
  inline ::svmp::Authentication* release_authentication();
  inline void set_allocated_authentication(::svmp::Authentication* authentication);

  // optional .svmp.VideoRequest videoRequest = 3;
  inline bool has_videorequest() const;
  inline void clear_videorequest();
  static const int kVideoRequestFieldNumber = 3;
  inline const ::svmp::VideoRequest& videorequest() const;
  inline ::svmp::VideoRequest* mutable_videorequest();
  inline ::svmp::VideoRequest* release_videorequest();
  inline void set_allocated_videorequest(::svmp::VideoRequest* videorequest);

  // optional .svmp.TouchEvent touch = 4;
  inline bool has_touch() const;
  inline void clear_touch();
  static const int kTouchFieldNumber = 4;
  inline const ::svmp::TouchEvent& touch() const;
  inline ::svmp::TouchEvent* mutable_touch();
  inline ::svmp::TouchEvent* release_touch();
  inline void set_allocated_touch(::svmp::TouchEvent* touch);

  // optional .svmp.SensorEvent sensor = 5;
  inline bool has_sensor() const;
  inline void clear_sensor();
  static const int kSensorFieldNumber = 5;
  inline const ::svmp::SensorEvent& sensor() const;
  inline ::svmp::SensorEvent* mutable_sensor();
  inline ::svmp::SensorEvent* release_sensor();
  inline void set_allocated_sensor(::svmp::SensorEvent* sensor);

  // optional .svmp.LocationRequest locationRequest = 6;
  inline bool has_locationrequest() const;
  inline void clear_locationrequest();
  static const int kLocationRequestFieldNumber = 6;
  inline const ::svmp::LocationRequest& locationrequest() const;
  inline ::svmp::LocationRequest* mutable_locationrequest();
  inline ::svmp::LocationRequest* release_locationrequest();
  inline void set_allocated_locationrequest(::svmp::LocationRequest* locationrequest);

  // optional .svmp.Intent intent = 7;
  inline bool has_intent() const;
  inline void clear_intent();
  static const int kIntentFieldNumber = 7;
  inline const ::svmp::Intent& intent() const;
  inline ::svmp::Intent* mutable_intent();
  inline ::svmp::Intent* release_intent();
  inline void set_allocated_intent(::svmp::Intent* intent);

  // optional .svmp.WebRTCMessage webrtcMsg = 9;
  inline bool has_webrtcmsg() const;
  inline void clear_webrtcmsg();
  static const int kWebrtcMsgFieldNumber = 9;
  inline const ::svmp::WebRTCMessage& webrtcmsg() const;
  inline ::svmp::WebRTCMessage* mutable_webrtcmsg();
  inline ::svmp::WebRTCMessage* release_webrtcmsg();
  inline void set_allocated_webrtcmsg(::svmp::WebRTCMessage* webrtcmsg);

  // @@protoc_insertion_point(class_scope:svmp.Request)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_authentication();
  inline void clear_has_authentication();
  inline void set_has_videorequest();
  inline void clear_has_videorequest();
  inline void set_has_touch();
  inline void clear_has_touch();
  inline void set_has_sensor();
  inline void clear_has_sensor();
  inline void set_has_locationrequest();
  inline void clear_has_locationrequest();
  inline void set_has_intent();
  inline void clear_has_intent();
  inline void set_has_webrtcmsg();
  inline void clear_has_webrtcmsg();

  ::svmp::Authentication* authentication_;
  ::svmp::VideoRequest* videorequest_;
  ::svmp::TouchEvent* touch_;
  ::svmp::SensorEvent* sensor_;
  ::svmp::LocationRequest* locationrequest_;
  ::svmp::Intent* intent_;
  ::svmp::WebRTCMessage* webrtcmsg_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::MessageLite {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  static const Response& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Response* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Response_ResponseType ResponseType;
  static const ResponseType ERROR = Response_ResponseType_ERROR;
  static const ResponseType AUTHOK = Response_ResponseType_AUTHOK;
  static const ResponseType VMREADY = Response_ResponseType_VMREADY;
  static const ResponseType SCREENINFO = Response_ResponseType_SCREENINFO;
  static const ResponseType WEBRTC = Response_ResponseType_WEBRTC;
  static const ResponseType INTENT = Response_ResponseType_INTENT;
  static const ResponseType NOTIFICATION = Response_ResponseType_NOTIFICATION;
  static const ResponseType LOCATION = Response_ResponseType_LOCATION;
  static const ResponseType VIDEOSTART = Response_ResponseType_VIDEOSTART;
  static const ResponseType VIDEOSTOP = Response_ResponseType_VIDEOSTOP;
  static const ResponseType VIDEOPAUSE = Response_ResponseType_VIDEOPAUSE;
  static inline bool ResponseType_IsValid(int value) {
    return Response_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Response_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Response_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    Response_ResponseType_ResponseType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .svmp.Response.ResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::Response_ResponseType type() const;
  inline void set_type(::svmp::Response_ResponseType value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional .svmp.Intent intent = 4;
  inline bool has_intent() const;
  inline void clear_intent();
  static const int kIntentFieldNumber = 4;
  inline const ::svmp::Intent& intent() const;
  inline ::svmp::Intent* mutable_intent();
  inline ::svmp::Intent* release_intent();
  inline void set_allocated_intent(::svmp::Intent* intent);

  // optional .svmp.Notification notification = 5;
  inline bool has_notification() const;
  inline void clear_notification();
  static const int kNotificationFieldNumber = 5;
  inline const ::svmp::Notification& notification() const;
  inline ::svmp::Notification* mutable_notification();
  inline ::svmp::Notification* release_notification();
  inline void set_allocated_notification(::svmp::Notification* notification);

  // optional .svmp.LocationResponse locationResponse = 6;
  inline bool has_locationresponse() const;
  inline void clear_locationresponse();
  static const int kLocationResponseFieldNumber = 6;
  inline const ::svmp::LocationResponse& locationresponse() const;
  inline ::svmp::LocationResponse* mutable_locationresponse();
  inline ::svmp::LocationResponse* release_locationresponse();
  inline void set_allocated_locationresponse(::svmp::LocationResponse* locationresponse);

  // optional .svmp.ScreenInfo screen_info = 16;
  inline bool has_screen_info() const;
  inline void clear_screen_info();
  static const int kScreenInfoFieldNumber = 16;
  inline const ::svmp::ScreenInfo& screen_info() const;
  inline ::svmp::ScreenInfo* mutable_screen_info();
  inline ::svmp::ScreenInfo* release_screen_info();
  inline void set_allocated_screen_info(::svmp::ScreenInfo* screen_info);

  // optional .svmp.WebRTCMessage webrtcMsg = 17;
  inline bool has_webrtcmsg() const;
  inline void clear_webrtcmsg();
  static const int kWebrtcMsgFieldNumber = 17;
  inline const ::svmp::WebRTCMessage& webrtcmsg() const;
  inline ::svmp::WebRTCMessage* mutable_webrtcmsg();
  inline ::svmp::WebRTCMessage* release_webrtcmsg();
  inline void set_allocated_webrtcmsg(::svmp::WebRTCMessage* webrtcmsg);

  // @@protoc_insertion_point(class_scope:svmp.Response)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_intent();
  inline void clear_has_intent();
  inline void set_has_notification();
  inline void clear_has_notification();
  inline void set_has_locationresponse();
  inline void clear_has_locationresponse();
  inline void set_has_screen_info();
  inline void clear_has_screen_info();
  inline void set_has_webrtcmsg();
  inline void clear_has_webrtcmsg();

  ::std::string* message_;
  ::svmp::Intent* intent_;
  ::svmp::Notification* notification_;
  ::svmp::LocationResponse* locationresponse_;
  ::svmp::ScreenInfo* screen_info_;
  ::svmp::WebRTCMessage* webrtcmsg_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Intent_Tuple : public ::google::protobuf::MessageLite {
 public:
  Intent_Tuple();
  virtual ~Intent_Tuple();

  Intent_Tuple(const Intent_Tuple& from);

  inline Intent_Tuple& operator=(const Intent_Tuple& from) {
    CopyFrom(from);
    return *this;
  }

  static const Intent_Tuple& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Intent_Tuple* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Intent_Tuple* other);

  // implements Message ----------------------------------------------

  Intent_Tuple* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Intent_Tuple& from);
  void MergeFrom(const Intent_Tuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:svmp.Intent.Tuple)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static Intent_Tuple* default_instance_;
};
// -------------------------------------------------------------------

class Intent : public ::google::protobuf::MessageLite {
 public:
  Intent();
  virtual ~Intent();

  Intent(const Intent& from);

  inline Intent& operator=(const Intent& from) {
    CopyFrom(from);
    return *this;
  }

  static const Intent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Intent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Intent* other);

  // implements Message ----------------------------------------------

  Intent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Intent& from);
  void MergeFrom(const Intent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Intent_Tuple Tuple;

  // accessors -------------------------------------------------------

  // required .svmp.IntentAction action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::svmp::IntentAction action() const;
  inline void set_action(::svmp::IntentAction value);

  // repeated .svmp.Intent.Tuple extras = 2;
  inline int extras_size() const;
  inline void clear_extras();
  static const int kExtrasFieldNumber = 2;
  inline const ::svmp::Intent_Tuple& extras(int index) const;
  inline ::svmp::Intent_Tuple* mutable_extras(int index);
  inline ::svmp::Intent_Tuple* add_extras();
  inline const ::google::protobuf::RepeatedPtrField< ::svmp::Intent_Tuple >&
      extras() const;
  inline ::google::protobuf::RepeatedPtrField< ::svmp::Intent_Tuple >*
      mutable_extras();

  // optional string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // repeated int32 flags = 4;
  inline int flags_size() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 4;
  inline ::google::protobuf::int32 flags(int index) const;
  inline void set_flags(int index, ::google::protobuf::int32 value);
  inline void add_flags(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      flags() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_flags();

  // repeated string categories = 5;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 5;
  inline const ::std::string& categories(int index) const;
  inline ::std::string* mutable_categories(int index);
  inline void set_categories(int index, const ::std::string& value);
  inline void set_categories(int index, const char* value);
  inline void set_categories(int index, const char* value, size_t size);
  inline ::std::string* add_categories();
  inline void add_categories(const ::std::string& value);
  inline void add_categories(const char* value);
  inline void add_categories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& categories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_categories();

  // @@protoc_insertion_point(class_scope:svmp.Intent)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::RepeatedPtrField< ::svmp::Intent_Tuple > extras_;
  ::std::string* data_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > flags_;
  ::google::protobuf::RepeatedPtrField< ::std::string> categories_;
  int action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static Intent* default_instance_;
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::MessageLite {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }

  static const Notification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Notification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Notification* other);

  // implements Message ----------------------------------------------

  Notification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string contentTitle = 1;
  inline bool has_contenttitle() const;
  inline void clear_contenttitle();
  static const int kContentTitleFieldNumber = 1;
  inline const ::std::string& contenttitle() const;
  inline void set_contenttitle(const ::std::string& value);
  inline void set_contenttitle(const char* value);
  inline void set_contenttitle(const char* value, size_t size);
  inline ::std::string* mutable_contenttitle();
  inline ::std::string* release_contenttitle();
  inline void set_allocated_contenttitle(::std::string* contenttitle);

  // required string contentText = 2;
  inline bool has_contenttext() const;
  inline void clear_contenttext();
  static const int kContentTextFieldNumber = 2;
  inline const ::std::string& contenttext() const;
  inline void set_contenttext(const ::std::string& value);
  inline void set_contenttext(const char* value);
  inline void set_contenttext(const char* value, size_t size);
  inline ::std::string* mutable_contenttext();
  inline ::std::string* release_contenttext();
  inline void set_allocated_contenttext(::std::string* contenttext);

  // required bytes smallIcon = 3;
  inline bool has_smallicon() const;
  inline void clear_smallicon();
  static const int kSmallIconFieldNumber = 3;
  inline const ::std::string& smallicon() const;
  inline void set_smallicon(const ::std::string& value);
  inline void set_smallicon(const char* value);
  inline void set_smallicon(const void* value, size_t size);
  inline ::std::string* mutable_smallicon();
  inline ::std::string* release_smallicon();
  inline void set_allocated_smallicon(::std::string* smallicon);

  // optional bytes largeIcon = 4;
  inline bool has_largeicon() const;
  inline void clear_largeicon();
  static const int kLargeIconFieldNumber = 4;
  inline const ::std::string& largeicon() const;
  inline void set_largeicon(const ::std::string& value);
  inline void set_largeicon(const char* value);
  inline void set_largeicon(const void* value, size_t size);
  inline ::std::string* mutable_largeicon();
  inline ::std::string* release_largeicon();
  inline void set_allocated_largeicon(::std::string* largeicon);

  // @@protoc_insertion_point(class_scope:svmp.Notification)
 private:
  inline void set_has_contenttitle();
  inline void clear_has_contenttitle();
  inline void set_has_contenttext();
  inline void clear_has_contenttext();
  inline void set_has_smallicon();
  inline void clear_has_smallicon();
  inline void set_has_largeicon();
  inline void clear_has_largeicon();

  ::std::string* contenttitle_;
  ::std::string* contenttext_;
  ::std::string* smallicon_;
  ::std::string* largeicon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static Notification* default_instance_;
};
// -------------------------------------------------------------------

class TouchEvent_PointerCoords : public ::google::protobuf::MessageLite {
 public:
  TouchEvent_PointerCoords();
  virtual ~TouchEvent_PointerCoords();

  TouchEvent_PointerCoords(const TouchEvent_PointerCoords& from);

  inline TouchEvent_PointerCoords& operator=(const TouchEvent_PointerCoords& from) {
    CopyFrom(from);
    return *this;
  }

  static const TouchEvent_PointerCoords& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TouchEvent_PointerCoords* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TouchEvent_PointerCoords* other);

  // implements Message ----------------------------------------------

  TouchEvent_PointerCoords* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TouchEvent_PointerCoords& from);
  void MergeFrom(const TouchEvent_PointerCoords& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required float x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:svmp.TouchEvent.PointerCoords)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::int32 id_;
  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static TouchEvent_PointerCoords* default_instance_;
};
// -------------------------------------------------------------------

class TouchEvent : public ::google::protobuf::MessageLite {
 public:
  TouchEvent();
  virtual ~TouchEvent();

  TouchEvent(const TouchEvent& from);

  inline TouchEvent& operator=(const TouchEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const TouchEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TouchEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TouchEvent* other);

  // implements Message ----------------------------------------------

  TouchEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TouchEvent& from);
  void MergeFrom(const TouchEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TouchEvent_PointerCoords PointerCoords;

  // accessors -------------------------------------------------------

  // required int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);

  // repeated .svmp.TouchEvent.PointerCoords items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::svmp::TouchEvent_PointerCoords& items(int index) const;
  inline ::svmp::TouchEvent_PointerCoords* mutable_items(int index);
  inline ::svmp::TouchEvent_PointerCoords* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::svmp::TouchEvent_PointerCoords >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::svmp::TouchEvent_PointerCoords >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:svmp.TouchEvent)
 private:
  inline void set_has_action();
  inline void clear_has_action();

  ::google::protobuf::RepeatedPtrField< ::svmp::TouchEvent_PointerCoords > items_;
  ::google::protobuf::int32 action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static TouchEvent* default_instance_;
};
// -------------------------------------------------------------------

class ScreenInfo : public ::google::protobuf::MessageLite {
 public:
  ScreenInfo();
  virtual ~ScreenInfo();

  ScreenInfo(const ScreenInfo& from);

  inline ScreenInfo& operator=(const ScreenInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ScreenInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ScreenInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ScreenInfo* other);

  // implements Message ----------------------------------------------

  ScreenInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ScreenInfo& from);
  void MergeFrom(const ScreenInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:svmp.ScreenInfo)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static ScreenInfo* default_instance_;
};
// -------------------------------------------------------------------

class SensorEvent : public ::google::protobuf::MessageLite {
 public:
  SensorEvent();
  virtual ~SensorEvent();

  SensorEvent(const SensorEvent& from);

  inline SensorEvent& operator=(const SensorEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const SensorEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SensorEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SensorEvent* other);

  // implements Message ----------------------------------------------

  SensorEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SensorEvent& from);
  void MergeFrom(const SensorEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .svmp.SensorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::SensorType type() const;
  inline void set_type(::svmp::SensorType value);

  // required int32 accuracy = 2;
  inline bool has_accuracy() const;
  inline void clear_accuracy();
  static const int kAccuracyFieldNumber = 2;
  inline ::google::protobuf::int32 accuracy() const;
  inline void set_accuracy(::google::protobuf::int32 value);

  // required int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // repeated float values = 4;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 4;
  inline float values(int index) const;
  inline void set_values(int index, float value);
  inline void add_values(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      values() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:svmp.SensorEvent)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_accuracy();
  inline void clear_has_accuracy();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  int type_;
  ::google::protobuf::int32 accuracy_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::RepeatedField< float > values_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static SensorEvent* default_instance_;
};
// -------------------------------------------------------------------

class SensorSubscribe : public ::google::protobuf::MessageLite {
 public:
  SensorSubscribe();
  virtual ~SensorSubscribe();

  SensorSubscribe(const SensorSubscribe& from);

  inline SensorSubscribe& operator=(const SensorSubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  static const SensorSubscribe& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SensorSubscribe* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SensorSubscribe* other);

  // implements Message ----------------------------------------------

  SensorSubscribe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SensorSubscribe& from);
  void MergeFrom(const SensorSubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .svmp.SensorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::SensorType type() const;
  inline void set_type(::svmp::SensorType value);

  // optional int32 frequency = 2;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 2;
  inline ::google::protobuf::int32 frequency() const;
  inline void set_frequency(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:svmp.SensorSubscribe)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_frequency();
  inline void clear_has_frequency();

  int type_;
  ::google::protobuf::int32 frequency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static SensorSubscribe* default_instance_;
};
// -------------------------------------------------------------------

class SensorUnsubscribe : public ::google::protobuf::MessageLite {
 public:
  SensorUnsubscribe();
  virtual ~SensorUnsubscribe();

  SensorUnsubscribe(const SensorUnsubscribe& from);

  inline SensorUnsubscribe& operator=(const SensorUnsubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  static const SensorUnsubscribe& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SensorUnsubscribe* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SensorUnsubscribe* other);

  // implements Message ----------------------------------------------

  SensorUnsubscribe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SensorUnsubscribe& from);
  void MergeFrom(const SensorUnsubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .svmp.SensorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::SensorType type() const;
  inline void set_type(::svmp::SensorType value);

  // @@protoc_insertion_point(class_scope:svmp.SensorUnsubscribe)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static SensorUnsubscribe* default_instance_;
};
// -------------------------------------------------------------------

class LocationProviderInfo : public ::google::protobuf::MessageLite {
 public:
  LocationProviderInfo();
  virtual ~LocationProviderInfo();

  LocationProviderInfo(const LocationProviderInfo& from);

  inline LocationProviderInfo& operator=(const LocationProviderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationProviderInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationProviderInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationProviderInfo* other);

  // implements Message ----------------------------------------------

  LocationProviderInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationProviderInfo& from);
  void MergeFrom(const LocationProviderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string provider = 1;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 1;
  inline const ::std::string& provider() const;
  inline void set_provider(const ::std::string& value);
  inline void set_provider(const char* value);
  inline void set_provider(const char* value, size_t size);
  inline ::std::string* mutable_provider();
  inline ::std::string* release_provider();
  inline void set_allocated_provider(::std::string* provider);

  // required bool requiresNetwork = 2;
  inline bool has_requiresnetwork() const;
  inline void clear_requiresnetwork();
  static const int kRequiresNetworkFieldNumber = 2;
  inline bool requiresnetwork() const;
  inline void set_requiresnetwork(bool value);

  // required bool requiresSatellite = 3;
  inline bool has_requiressatellite() const;
  inline void clear_requiressatellite();
  static const int kRequiresSatelliteFieldNumber = 3;
  inline bool requiressatellite() const;
  inline void set_requiressatellite(bool value);

  // required bool requiresCell = 4;
  inline bool has_requirescell() const;
  inline void clear_requirescell();
  static const int kRequiresCellFieldNumber = 4;
  inline bool requirescell() const;
  inline void set_requirescell(bool value);

  // required bool hasMonetaryCost = 5;
  inline bool has_hasmonetarycost() const;
  inline void clear_hasmonetarycost();
  static const int kHasMonetaryCostFieldNumber = 5;
  inline bool hasmonetarycost() const;
  inline void set_hasmonetarycost(bool value);

  // required bool supportsAltitude = 6;
  inline bool has_supportsaltitude() const;
  inline void clear_supportsaltitude();
  static const int kSupportsAltitudeFieldNumber = 6;
  inline bool supportsaltitude() const;
  inline void set_supportsaltitude(bool value);

  // required bool supportsSpeed = 7;
  inline bool has_supportsspeed() const;
  inline void clear_supportsspeed();
  static const int kSupportsSpeedFieldNumber = 7;
  inline bool supportsspeed() const;
  inline void set_supportsspeed(bool value);

  // required bool supportsBearing = 8;
  inline bool has_supportsbearing() const;
  inline void clear_supportsbearing();
  static const int kSupportsBearingFieldNumber = 8;
  inline bool supportsbearing() const;
  inline void set_supportsbearing(bool value);

  // required int32 powerRequirement = 9;
  inline bool has_powerrequirement() const;
  inline void clear_powerrequirement();
  static const int kPowerRequirementFieldNumber = 9;
  inline ::google::protobuf::int32 powerrequirement() const;
  inline void set_powerrequirement(::google::protobuf::int32 value);

  // required int32 accuracy = 10;
  inline bool has_accuracy() const;
  inline void clear_accuracy();
  static const int kAccuracyFieldNumber = 10;
  inline ::google::protobuf::int32 accuracy() const;
  inline void set_accuracy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:svmp.LocationProviderInfo)
 private:
  inline void set_has_provider();
  inline void clear_has_provider();
  inline void set_has_requiresnetwork();
  inline void clear_has_requiresnetwork();
  inline void set_has_requiressatellite();
  inline void clear_has_requiressatellite();
  inline void set_has_requirescell();
  inline void clear_has_requirescell();
  inline void set_has_hasmonetarycost();
  inline void clear_has_hasmonetarycost();
  inline void set_has_supportsaltitude();
  inline void clear_has_supportsaltitude();
  inline void set_has_supportsspeed();
  inline void clear_has_supportsspeed();
  inline void set_has_supportsbearing();
  inline void clear_has_supportsbearing();
  inline void set_has_powerrequirement();
  inline void clear_has_powerrequirement();
  inline void set_has_accuracy();
  inline void clear_has_accuracy();

  ::std::string* provider_;
  bool requiresnetwork_;
  bool requiressatellite_;
  bool requirescell_;
  bool hasmonetarycost_;
  bool supportsaltitude_;
  bool supportsspeed_;
  bool supportsbearing_;
  ::google::protobuf::int32 powerrequirement_;
  ::google::protobuf::int32 accuracy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationProviderInfo* default_instance_;
};
// -------------------------------------------------------------------

class LocationProviderStatus_Tuple : public ::google::protobuf::MessageLite {
 public:
  LocationProviderStatus_Tuple();
  virtual ~LocationProviderStatus_Tuple();

  LocationProviderStatus_Tuple(const LocationProviderStatus_Tuple& from);

  inline LocationProviderStatus_Tuple& operator=(const LocationProviderStatus_Tuple& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationProviderStatus_Tuple& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationProviderStatus_Tuple* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationProviderStatus_Tuple* other);

  // implements Message ----------------------------------------------

  LocationProviderStatus_Tuple* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationProviderStatus_Tuple& from);
  void MergeFrom(const LocationProviderStatus_Tuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:svmp.LocationProviderStatus.Tuple)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationProviderStatus_Tuple* default_instance_;
};
// -------------------------------------------------------------------

class LocationProviderStatus : public ::google::protobuf::MessageLite {
 public:
  LocationProviderStatus();
  virtual ~LocationProviderStatus();

  LocationProviderStatus(const LocationProviderStatus& from);

  inline LocationProviderStatus& operator=(const LocationProviderStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationProviderStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationProviderStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationProviderStatus* other);

  // implements Message ----------------------------------------------

  LocationProviderStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationProviderStatus& from);
  void MergeFrom(const LocationProviderStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LocationProviderStatus_Tuple Tuple;

  // accessors -------------------------------------------------------

  // required string provider = 1;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 1;
  inline const ::std::string& provider() const;
  inline void set_provider(const ::std::string& value);
  inline void set_provider(const char* value);
  inline void set_provider(const char* value, size_t size);
  inline ::std::string* mutable_provider();
  inline ::std::string* release_provider();
  inline void set_allocated_provider(::std::string* provider);

  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated .svmp.LocationProviderStatus.Tuple extras = 3;
  inline int extras_size() const;
  inline void clear_extras();
  static const int kExtrasFieldNumber = 3;
  inline const ::svmp::LocationProviderStatus_Tuple& extras(int index) const;
  inline ::svmp::LocationProviderStatus_Tuple* mutable_extras(int index);
  inline ::svmp::LocationProviderStatus_Tuple* add_extras();
  inline const ::google::protobuf::RepeatedPtrField< ::svmp::LocationProviderStatus_Tuple >&
      extras() const;
  inline ::google::protobuf::RepeatedPtrField< ::svmp::LocationProviderStatus_Tuple >*
      mutable_extras();

  // @@protoc_insertion_point(class_scope:svmp.LocationProviderStatus)
 private:
  inline void set_has_provider();
  inline void clear_has_provider();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string* provider_;
  ::google::protobuf::RepeatedPtrField< ::svmp::LocationProviderStatus_Tuple > extras_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationProviderStatus* default_instance_;
};
// -------------------------------------------------------------------

class LocationProviderEnabled : public ::google::protobuf::MessageLite {
 public:
  LocationProviderEnabled();
  virtual ~LocationProviderEnabled();

  LocationProviderEnabled(const LocationProviderEnabled& from);

  inline LocationProviderEnabled& operator=(const LocationProviderEnabled& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationProviderEnabled& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationProviderEnabled* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationProviderEnabled* other);

  // implements Message ----------------------------------------------

  LocationProviderEnabled* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationProviderEnabled& from);
  void MergeFrom(const LocationProviderEnabled& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string provider = 1;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 1;
  inline const ::std::string& provider() const;
  inline void set_provider(const ::std::string& value);
  inline void set_provider(const char* value);
  inline void set_provider(const char* value, size_t size);
  inline ::std::string* mutable_provider();
  inline ::std::string* release_provider();
  inline void set_allocated_provider(::std::string* provider);

  // required bool enabled = 2;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:svmp.LocationProviderEnabled)
 private:
  inline void set_has_provider();
  inline void clear_has_provider();
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::std::string* provider_;
  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationProviderEnabled* default_instance_;
};
// -------------------------------------------------------------------

class LocationUpdate : public ::google::protobuf::MessageLite {
 public:
  LocationUpdate();
  virtual ~LocationUpdate();

  LocationUpdate(const LocationUpdate& from);

  inline LocationUpdate& operator=(const LocationUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationUpdate* other);

  // implements Message ----------------------------------------------

  LocationUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationUpdate& from);
  void MergeFrom(const LocationUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline double latitude() const;
  inline void set_latitude(double value);

  // required double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);

  // required int64 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string provider = 4;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 4;
  inline const ::std::string& provider() const;
  inline void set_provider(const ::std::string& value);
  inline void set_provider(const char* value);
  inline void set_provider(const char* value, size_t size);
  inline ::std::string* mutable_provider();
  inline ::std::string* release_provider();
  inline void set_allocated_provider(::std::string* provider);

  // optional float accuracy = 5;
  inline bool has_accuracy() const;
  inline void clear_accuracy();
  static const int kAccuracyFieldNumber = 5;
  inline float accuracy() const;
  inline void set_accuracy(float value);

  // optional double altitude = 6;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 6;
  inline double altitude() const;
  inline void set_altitude(double value);

  // optional float bearing = 7;
  inline bool has_bearing() const;
  inline void clear_bearing();
  static const int kBearingFieldNumber = 7;
  inline float bearing() const;
  inline void set_bearing(float value);

  // optional float speed = 8;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 8;
  inline float speed() const;
  inline void set_speed(float value);

  // @@protoc_insertion_point(class_scope:svmp.LocationUpdate)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_provider();
  inline void clear_has_provider();
  inline void set_has_accuracy();
  inline void clear_has_accuracy();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_bearing();
  inline void clear_has_bearing();
  inline void set_has_speed();
  inline void clear_has_speed();

  double latitude_;
  double longitude_;
  ::google::protobuf::int64 time_;
  ::std::string* provider_;
  double altitude_;
  float accuracy_;
  float bearing_;
  float speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationUpdate* default_instance_;
};
// -------------------------------------------------------------------

class LocationRequest : public ::google::protobuf::MessageLite {
 public:
  LocationRequest();
  virtual ~LocationRequest();

  LocationRequest(const LocationRequest& from);

  inline LocationRequest& operator=(const LocationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationRequest* other);

  // implements Message ----------------------------------------------

  LocationRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationRequest& from);
  void MergeFrom(const LocationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LocationRequest_LocationRequestType LocationRequestType;
  static const LocationRequestType PROVIDERINFO = LocationRequest_LocationRequestType_PROVIDERINFO;
  static const LocationRequestType PROVIDERSTATUS = LocationRequest_LocationRequestType_PROVIDERSTATUS;
  static const LocationRequestType PROVIDERENABLED = LocationRequest_LocationRequestType_PROVIDERENABLED;
  static const LocationRequestType LOCATIONUPDATE = LocationRequest_LocationRequestType_LOCATIONUPDATE;
  static inline bool LocationRequestType_IsValid(int value) {
    return LocationRequest_LocationRequestType_IsValid(value);
  }
  static const LocationRequestType LocationRequestType_MIN =
    LocationRequest_LocationRequestType_LocationRequestType_MIN;
  static const LocationRequestType LocationRequestType_MAX =
    LocationRequest_LocationRequestType_LocationRequestType_MAX;
  static const int LocationRequestType_ARRAYSIZE =
    LocationRequest_LocationRequestType_LocationRequestType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .svmp.LocationRequest.LocationRequestType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::LocationRequest_LocationRequestType type() const;
  inline void set_type(::svmp::LocationRequest_LocationRequestType value);

  // optional .svmp.LocationProviderInfo providerInfo = 2;
  inline bool has_providerinfo() const;
  inline void clear_providerinfo();
  static const int kProviderInfoFieldNumber = 2;
  inline const ::svmp::LocationProviderInfo& providerinfo() const;
  inline ::svmp::LocationProviderInfo* mutable_providerinfo();
  inline ::svmp::LocationProviderInfo* release_providerinfo();
  inline void set_allocated_providerinfo(::svmp::LocationProviderInfo* providerinfo);

  // optional .svmp.LocationProviderStatus providerStatus = 3;
  inline bool has_providerstatus() const;
  inline void clear_providerstatus();
  static const int kProviderStatusFieldNumber = 3;
  inline const ::svmp::LocationProviderStatus& providerstatus() const;
  inline ::svmp::LocationProviderStatus* mutable_providerstatus();
  inline ::svmp::LocationProviderStatus* release_providerstatus();
  inline void set_allocated_providerstatus(::svmp::LocationProviderStatus* providerstatus);

  // optional .svmp.LocationProviderEnabled providerEnabled = 4;
  inline bool has_providerenabled() const;
  inline void clear_providerenabled();
  static const int kProviderEnabledFieldNumber = 4;
  inline const ::svmp::LocationProviderEnabled& providerenabled() const;
  inline ::svmp::LocationProviderEnabled* mutable_providerenabled();
  inline ::svmp::LocationProviderEnabled* release_providerenabled();
  inline void set_allocated_providerenabled(::svmp::LocationProviderEnabled* providerenabled);

  // optional .svmp.LocationUpdate update = 5;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 5;
  inline const ::svmp::LocationUpdate& update() const;
  inline ::svmp::LocationUpdate* mutable_update();
  inline ::svmp::LocationUpdate* release_update();
  inline void set_allocated_update(::svmp::LocationUpdate* update);

  // @@protoc_insertion_point(class_scope:svmp.LocationRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_providerinfo();
  inline void clear_has_providerinfo();
  inline void set_has_providerstatus();
  inline void clear_has_providerstatus();
  inline void set_has_providerenabled();
  inline void clear_has_providerenabled();
  inline void set_has_update();
  inline void clear_has_update();

  ::svmp::LocationProviderInfo* providerinfo_;
  ::svmp::LocationProviderStatus* providerstatus_;
  ::svmp::LocationProviderEnabled* providerenabled_;
  ::svmp::LocationUpdate* update_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationRequest* default_instance_;
};
// -------------------------------------------------------------------

class LocationSubscribe : public ::google::protobuf::MessageLite {
 public:
  LocationSubscribe();
  virtual ~LocationSubscribe();

  LocationSubscribe(const LocationSubscribe& from);

  inline LocationSubscribe& operator=(const LocationSubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationSubscribe& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationSubscribe* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationSubscribe* other);

  // implements Message ----------------------------------------------

  LocationSubscribe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationSubscribe& from);
  void MergeFrom(const LocationSubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LocationSubscribe_LocationSubscribeType LocationSubscribeType;
  static const LocationSubscribeType SINGLE_UPDATE = LocationSubscribe_LocationSubscribeType_SINGLE_UPDATE;
  static const LocationSubscribeType MULTIPLE_UPDATES = LocationSubscribe_LocationSubscribeType_MULTIPLE_UPDATES;
  static inline bool LocationSubscribeType_IsValid(int value) {
    return LocationSubscribe_LocationSubscribeType_IsValid(value);
  }
  static const LocationSubscribeType LocationSubscribeType_MIN =
    LocationSubscribe_LocationSubscribeType_LocationSubscribeType_MIN;
  static const LocationSubscribeType LocationSubscribeType_MAX =
    LocationSubscribe_LocationSubscribeType_LocationSubscribeType_MAX;
  static const int LocationSubscribeType_ARRAYSIZE =
    LocationSubscribe_LocationSubscribeType_LocationSubscribeType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .svmp.LocationSubscribe.LocationSubscribeType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::LocationSubscribe_LocationSubscribeType type() const;
  inline void set_type(::svmp::LocationSubscribe_LocationSubscribeType value);

  // required string provider = 2;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 2;
  inline const ::std::string& provider() const;
  inline void set_provider(const ::std::string& value);
  inline void set_provider(const char* value);
  inline void set_provider(const char* value, size_t size);
  inline ::std::string* mutable_provider();
  inline ::std::string* release_provider();
  inline void set_allocated_provider(::std::string* provider);

  // optional int64 minTime = 3;
  inline bool has_mintime() const;
  inline void clear_mintime();
  static const int kMinTimeFieldNumber = 3;
  inline ::google::protobuf::int64 mintime() const;
  inline void set_mintime(::google::protobuf::int64 value);

  // optional float minDistance = 4;
  inline bool has_mindistance() const;
  inline void clear_mindistance();
  static const int kMinDistanceFieldNumber = 4;
  inline float mindistance() const;
  inline void set_mindistance(float value);

  // @@protoc_insertion_point(class_scope:svmp.LocationSubscribe)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_provider();
  inline void clear_has_provider();
  inline void set_has_mintime();
  inline void clear_has_mintime();
  inline void set_has_mindistance();
  inline void clear_has_mindistance();

  ::std::string* provider_;
  int type_;
  float mindistance_;
  ::google::protobuf::int64 mintime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationSubscribe* default_instance_;
};
// -------------------------------------------------------------------

class LocationUnsubscribe : public ::google::protobuf::MessageLite {
 public:
  LocationUnsubscribe();
  virtual ~LocationUnsubscribe();

  LocationUnsubscribe(const LocationUnsubscribe& from);

  inline LocationUnsubscribe& operator=(const LocationUnsubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationUnsubscribe& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationUnsubscribe* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationUnsubscribe* other);

  // implements Message ----------------------------------------------

  LocationUnsubscribe* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationUnsubscribe& from);
  void MergeFrom(const LocationUnsubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string provider = 1;
  inline bool has_provider() const;
  inline void clear_provider();
  static const int kProviderFieldNumber = 1;
  inline const ::std::string& provider() const;
  inline void set_provider(const ::std::string& value);
  inline void set_provider(const char* value);
  inline void set_provider(const char* value, size_t size);
  inline ::std::string* mutable_provider();
  inline ::std::string* release_provider();
  inline void set_allocated_provider(::std::string* provider);

  // @@protoc_insertion_point(class_scope:svmp.LocationUnsubscribe)
 private:
  inline void set_has_provider();
  inline void clear_has_provider();

  ::std::string* provider_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationUnsubscribe* default_instance_;
};
// -------------------------------------------------------------------

class LocationResponse : public ::google::protobuf::MessageLite {
 public:
  LocationResponse();
  virtual ~LocationResponse();

  LocationResponse(const LocationResponse& from);

  inline LocationResponse& operator=(const LocationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const LocationResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LocationResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LocationResponse* other);

  // implements Message ----------------------------------------------

  LocationResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationResponse& from);
  void MergeFrom(const LocationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LocationResponse_LocationResponseType LocationResponseType;
  static const LocationResponseType SUBSCRIBE = LocationResponse_LocationResponseType_SUBSCRIBE;
  static const LocationResponseType UNSUBSCRIBE = LocationResponse_LocationResponseType_UNSUBSCRIBE;
  static inline bool LocationResponseType_IsValid(int value) {
    return LocationResponse_LocationResponseType_IsValid(value);
  }
  static const LocationResponseType LocationResponseType_MIN =
    LocationResponse_LocationResponseType_LocationResponseType_MIN;
  static const LocationResponseType LocationResponseType_MAX =
    LocationResponse_LocationResponseType_LocationResponseType_MAX;
  static const int LocationResponseType_ARRAYSIZE =
    LocationResponse_LocationResponseType_LocationResponseType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .svmp.LocationResponse.LocationResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::LocationResponse_LocationResponseType type() const;
  inline void set_type(::svmp::LocationResponse_LocationResponseType value);

  // optional .svmp.LocationSubscribe subscribe = 2;
  inline bool has_subscribe() const;
  inline void clear_subscribe();
  static const int kSubscribeFieldNumber = 2;
  inline const ::svmp::LocationSubscribe& subscribe() const;
  inline ::svmp::LocationSubscribe* mutable_subscribe();
  inline ::svmp::LocationSubscribe* release_subscribe();
  inline void set_allocated_subscribe(::svmp::LocationSubscribe* subscribe);

  // optional .svmp.LocationUnsubscribe unsubscribe = 3;
  inline bool has_unsubscribe() const;
  inline void clear_unsubscribe();
  static const int kUnsubscribeFieldNumber = 3;
  inline const ::svmp::LocationUnsubscribe& unsubscribe() const;
  inline ::svmp::LocationUnsubscribe* mutable_unsubscribe();
  inline ::svmp::LocationUnsubscribe* release_unsubscribe();
  inline void set_allocated_unsubscribe(::svmp::LocationUnsubscribe* unsubscribe);

  // @@protoc_insertion_point(class_scope:svmp.LocationResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_subscribe();
  inline void clear_has_subscribe();
  inline void set_has_unsubscribe();
  inline void clear_has_unsubscribe();

  ::svmp::LocationSubscribe* subscribe_;
  ::svmp::LocationUnsubscribe* unsubscribe_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static LocationResponse* default_instance_;
};
// -------------------------------------------------------------------

class Authentication : public ::google::protobuf::MessageLite {
 public:
  Authentication();
  virtual ~Authentication();

  Authentication(const Authentication& from);

  inline Authentication& operator=(const Authentication& from) {
    CopyFrom(from);
    return *this;
  }

  static const Authentication& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Authentication* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Authentication* other);

  // implements Message ----------------------------------------------

  Authentication* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Authentication& from);
  void MergeFrom(const Authentication& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string un = 1;
  inline bool has_un() const;
  inline void clear_un();
  static const int kUnFieldNumber = 1;
  inline const ::std::string& un() const;
  inline void set_un(const ::std::string& value);
  inline void set_un(const char* value);
  inline void set_un(const char* value, size_t size);
  inline ::std::string* mutable_un();
  inline ::std::string* release_un();
  inline void set_allocated_un(::std::string* un);

  // required string pw = 2;
  inline bool has_pw() const;
  inline void clear_pw();
  static const int kPwFieldNumber = 2;
  inline const ::std::string& pw() const;
  inline void set_pw(const ::std::string& value);
  inline void set_pw(const char* value);
  inline void set_pw(const char* value, size_t size);
  inline ::std::string* mutable_pw();
  inline ::std::string* release_pw();
  inline void set_allocated_pw(::std::string* pw);

  // @@protoc_insertion_point(class_scope:svmp.Authentication)
 private:
  inline void set_has_un();
  inline void clear_has_un();
  inline void set_has_pw();
  inline void clear_has_pw();

  ::std::string* un_;
  ::std::string* pw_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static Authentication* default_instance_;
};
// -------------------------------------------------------------------

class VideoRequest : public ::google::protobuf::MessageLite {
 public:
  VideoRequest();
  virtual ~VideoRequest();

  VideoRequest(const VideoRequest& from);

  inline VideoRequest& operator=(const VideoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const VideoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VideoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VideoRequest* other);

  // implements Message ----------------------------------------------

  VideoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VideoRequest& from);
  void MergeFrom(const VideoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional int32 bitrate = 3;
  inline bool has_bitrate() const;
  inline void clear_bitrate();
  static const int kBitrateFieldNumber = 3;
  inline ::google::protobuf::int32 bitrate() const;
  inline void set_bitrate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:svmp.VideoRequest)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_bitrate();
  inline void clear_has_bitrate();

  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 bitrate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static VideoRequest* default_instance_;
};
// -------------------------------------------------------------------

class WebRTCMessage : public ::google::protobuf::MessageLite {
 public:
  WebRTCMessage();
  virtual ~WebRTCMessage();

  WebRTCMessage(const WebRTCMessage& from);

  inline WebRTCMessage& operator=(const WebRTCMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const WebRTCMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WebRTCMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WebRTCMessage* other);

  // implements Message ----------------------------------------------

  WebRTCMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WebRTCMessage& from);
  void MergeFrom(const WebRTCMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef WebRTCMessage_WebRTCType WebRTCType;
  static const WebRTCType OFFER = WebRTCMessage_WebRTCType_OFFER;
  static const WebRTCType ANSWER = WebRTCMessage_WebRTCType_ANSWER;
  static const WebRTCType CANDIDATE = WebRTCMessage_WebRTCType_CANDIDATE;
  static const WebRTCType BYE = WebRTCMessage_WebRTCType_BYE;
  static inline bool WebRTCType_IsValid(int value) {
    return WebRTCMessage_WebRTCType_IsValid(value);
  }
  static const WebRTCType WebRTCType_MIN =
    WebRTCMessage_WebRTCType_WebRTCType_MIN;
  static const WebRTCType WebRTCType_MAX =
    WebRTCMessage_WebRTCType_WebRTCType_MAX;
  static const int WebRTCType_ARRAYSIZE =
    WebRTCMessage_WebRTCType_WebRTCType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .svmp.WebRTCMessage.WebRTCType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::svmp::WebRTCMessage_WebRTCType type() const;
  inline void set_type(::svmp::WebRTCMessage_WebRTCType value);

  // optional string sdp = 2;
  inline bool has_sdp() const;
  inline void clear_sdp();
  static const int kSdpFieldNumber = 2;
  inline const ::std::string& sdp() const;
  inline void set_sdp(const ::std::string& value);
  inline void set_sdp(const char* value);
  inline void set_sdp(const char* value, size_t size);
  inline ::std::string* mutable_sdp();
  inline ::std::string* release_sdp();
  inline void set_allocated_sdp(::std::string* sdp);

  // optional string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 labal = 4;
  inline bool has_labal() const;
  inline void clear_labal();
  static const int kLabalFieldNumber = 4;
  inline ::google::protobuf::int32 labal() const;
  inline void set_labal(::google::protobuf::int32 value);

  // optional string candidate = 5;
  inline bool has_candidate() const;
  inline void clear_candidate();
  static const int kCandidateFieldNumber = 5;
  inline const ::std::string& candidate() const;
  inline void set_candidate(const ::std::string& value);
  inline void set_candidate(const char* value);
  inline void set_candidate(const char* value, size_t size);
  inline ::std::string* mutable_candidate();
  inline ::std::string* release_candidate();
  inline void set_allocated_candidate(::std::string* candidate);

  // @@protoc_insertion_point(class_scope:svmp.WebRTCMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sdp();
  inline void clear_has_sdp();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_labal();
  inline void clear_has_labal();
  inline void set_has_candidate();
  inline void clear_has_candidate();

  ::std::string* sdp_;
  int type_;
  ::google::protobuf::int32 labal_;
  ::std::string* id_;
  ::std::string* candidate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_svmp_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_svmp_2eproto();
  #endif
  friend void protobuf_AssignDesc_svmp_2eproto();
  friend void protobuf_ShutdownFile_svmp_2eproto();

  void InitAsDefaultInstance();
  static WebRTCMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// Request

// required .svmp.Request.RequestType type = 1;
inline bool Request::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::svmp::Request_RequestType Request::type() const {
  return static_cast< ::svmp::Request_RequestType >(type_);
}
inline void Request::set_type(::svmp::Request_RequestType value) {
  assert(::svmp::Request_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .svmp.Authentication authentication = 2;
inline bool Request::has_authentication() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_authentication() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_authentication() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_authentication() {
  if (authentication_ != NULL) authentication_->::svmp::Authentication::Clear();
  clear_has_authentication();
}
inline const ::svmp::Authentication& Request::authentication() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authentication_ != NULL ? *authentication_ : *default_instance().authentication_;
#else
  return authentication_ != NULL ? *authentication_ : *default_instance_->authentication_;
#endif
}
inline ::svmp::Authentication* Request::mutable_authentication() {
  set_has_authentication();
  if (authentication_ == NULL) authentication_ = new ::svmp::Authentication;
  return authentication_;
}
inline ::svmp::Authentication* Request::release_authentication() {
  clear_has_authentication();
  ::svmp::Authentication* temp = authentication_;
  authentication_ = NULL;
  return temp;
}
inline void Request::set_allocated_authentication(::svmp::Authentication* authentication) {
  delete authentication_;
  authentication_ = authentication;
  if (authentication) {
    set_has_authentication();
  } else {
    clear_has_authentication();
  }
}

// optional .svmp.VideoRequest videoRequest = 3;
inline bool Request::has_videorequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_videorequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_videorequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_videorequest() {
  if (videorequest_ != NULL) videorequest_->::svmp::VideoRequest::Clear();
  clear_has_videorequest();
}
inline const ::svmp::VideoRequest& Request::videorequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return videorequest_ != NULL ? *videorequest_ : *default_instance().videorequest_;
#else
  return videorequest_ != NULL ? *videorequest_ : *default_instance_->videorequest_;
#endif
}
inline ::svmp::VideoRequest* Request::mutable_videorequest() {
  set_has_videorequest();
  if (videorequest_ == NULL) videorequest_ = new ::svmp::VideoRequest;
  return videorequest_;
}
inline ::svmp::VideoRequest* Request::release_videorequest() {
  clear_has_videorequest();
  ::svmp::VideoRequest* temp = videorequest_;
  videorequest_ = NULL;
  return temp;
}
inline void Request::set_allocated_videorequest(::svmp::VideoRequest* videorequest) {
  delete videorequest_;
  videorequest_ = videorequest;
  if (videorequest) {
    set_has_videorequest();
  } else {
    clear_has_videorequest();
  }
}

// optional .svmp.TouchEvent touch = 4;
inline bool Request::has_touch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_touch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_touch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_touch() {
  if (touch_ != NULL) touch_->::svmp::TouchEvent::Clear();
  clear_has_touch();
}
inline const ::svmp::TouchEvent& Request::touch() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return touch_ != NULL ? *touch_ : *default_instance().touch_;
#else
  return touch_ != NULL ? *touch_ : *default_instance_->touch_;
#endif
}
inline ::svmp::TouchEvent* Request::mutable_touch() {
  set_has_touch();
  if (touch_ == NULL) touch_ = new ::svmp::TouchEvent;
  return touch_;
}
inline ::svmp::TouchEvent* Request::release_touch() {
  clear_has_touch();
  ::svmp::TouchEvent* temp = touch_;
  touch_ = NULL;
  return temp;
}
inline void Request::set_allocated_touch(::svmp::TouchEvent* touch) {
  delete touch_;
  touch_ = touch;
  if (touch) {
    set_has_touch();
  } else {
    clear_has_touch();
  }
}

// optional .svmp.SensorEvent sensor = 5;
inline bool Request::has_sensor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_sensor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_sensor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_sensor() {
  if (sensor_ != NULL) sensor_->::svmp::SensorEvent::Clear();
  clear_has_sensor();
}
inline const ::svmp::SensorEvent& Request::sensor() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sensor_ != NULL ? *sensor_ : *default_instance().sensor_;
#else
  return sensor_ != NULL ? *sensor_ : *default_instance_->sensor_;
#endif
}
inline ::svmp::SensorEvent* Request::mutable_sensor() {
  set_has_sensor();
  if (sensor_ == NULL) sensor_ = new ::svmp::SensorEvent;
  return sensor_;
}
inline ::svmp::SensorEvent* Request::release_sensor() {
  clear_has_sensor();
  ::svmp::SensorEvent* temp = sensor_;
  sensor_ = NULL;
  return temp;
}
inline void Request::set_allocated_sensor(::svmp::SensorEvent* sensor) {
  delete sensor_;
  sensor_ = sensor;
  if (sensor) {
    set_has_sensor();
  } else {
    clear_has_sensor();
  }
}

// optional .svmp.LocationRequest locationRequest = 6;
inline bool Request::has_locationrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_locationrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_locationrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_locationrequest() {
  if (locationrequest_ != NULL) locationrequest_->::svmp::LocationRequest::Clear();
  clear_has_locationrequest();
}
inline const ::svmp::LocationRequest& Request::locationrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return locationrequest_ != NULL ? *locationrequest_ : *default_instance().locationrequest_;
#else
  return locationrequest_ != NULL ? *locationrequest_ : *default_instance_->locationrequest_;
#endif
}
inline ::svmp::LocationRequest* Request::mutable_locationrequest() {
  set_has_locationrequest();
  if (locationrequest_ == NULL) locationrequest_ = new ::svmp::LocationRequest;
  return locationrequest_;
}
inline ::svmp::LocationRequest* Request::release_locationrequest() {
  clear_has_locationrequest();
  ::svmp::LocationRequest* temp = locationrequest_;
  locationrequest_ = NULL;
  return temp;
}
inline void Request::set_allocated_locationrequest(::svmp::LocationRequest* locationrequest) {
  delete locationrequest_;
  locationrequest_ = locationrequest;
  if (locationrequest) {
    set_has_locationrequest();
  } else {
    clear_has_locationrequest();
  }
}

// optional .svmp.Intent intent = 7;
inline bool Request::has_intent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_intent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_intent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_intent() {
  if (intent_ != NULL) intent_->::svmp::Intent::Clear();
  clear_has_intent();
}
inline const ::svmp::Intent& Request::intent() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return intent_ != NULL ? *intent_ : *default_instance().intent_;
#else
  return intent_ != NULL ? *intent_ : *default_instance_->intent_;
#endif
}
inline ::svmp::Intent* Request::mutable_intent() {
  set_has_intent();
  if (intent_ == NULL) intent_ = new ::svmp::Intent;
  return intent_;
}
inline ::svmp::Intent* Request::release_intent() {
  clear_has_intent();
  ::svmp::Intent* temp = intent_;
  intent_ = NULL;
  return temp;
}
inline void Request::set_allocated_intent(::svmp::Intent* intent) {
  delete intent_;
  intent_ = intent;
  if (intent) {
    set_has_intent();
  } else {
    clear_has_intent();
  }
}

// optional .svmp.WebRTCMessage webrtcMsg = 9;
inline bool Request::has_webrtcmsg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_webrtcmsg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_webrtcmsg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_webrtcmsg() {
  if (webrtcmsg_ != NULL) webrtcmsg_->::svmp::WebRTCMessage::Clear();
  clear_has_webrtcmsg();
}
inline const ::svmp::WebRTCMessage& Request::webrtcmsg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return webrtcmsg_ != NULL ? *webrtcmsg_ : *default_instance().webrtcmsg_;
#else
  return webrtcmsg_ != NULL ? *webrtcmsg_ : *default_instance_->webrtcmsg_;
#endif
}
inline ::svmp::WebRTCMessage* Request::mutable_webrtcmsg() {
  set_has_webrtcmsg();
  if (webrtcmsg_ == NULL) webrtcmsg_ = new ::svmp::WebRTCMessage;
  return webrtcmsg_;
}
inline ::svmp::WebRTCMessage* Request::release_webrtcmsg() {
  clear_has_webrtcmsg();
  ::svmp::WebRTCMessage* temp = webrtcmsg_;
  webrtcmsg_ = NULL;
  return temp;
}
inline void Request::set_allocated_webrtcmsg(::svmp::WebRTCMessage* webrtcmsg) {
  delete webrtcmsg_;
  webrtcmsg_ = webrtcmsg;
  if (webrtcmsg) {
    set_has_webrtcmsg();
  } else {
    clear_has_webrtcmsg();
  }
}

// -------------------------------------------------------------------

// Response

// required .svmp.Response.ResponseType type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::svmp::Response_ResponseType Response::type() const {
  return static_cast< ::svmp::Response_ResponseType >(type_);
}
inline void Response::set_type(::svmp::Response_ResponseType value) {
  assert(::svmp::Response_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string message = 2;
inline bool Response::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Response::message() const {
  return *message_;
}
inline void Response::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Response::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Response::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Response::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .svmp.Intent intent = 4;
inline bool Response::has_intent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_intent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_intent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_intent() {
  if (intent_ != NULL) intent_->::svmp::Intent::Clear();
  clear_has_intent();
}
inline const ::svmp::Intent& Response::intent() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return intent_ != NULL ? *intent_ : *default_instance().intent_;
#else
  return intent_ != NULL ? *intent_ : *default_instance_->intent_;
#endif
}
inline ::svmp::Intent* Response::mutable_intent() {
  set_has_intent();
  if (intent_ == NULL) intent_ = new ::svmp::Intent;
  return intent_;
}
inline ::svmp::Intent* Response::release_intent() {
  clear_has_intent();
  ::svmp::Intent* temp = intent_;
  intent_ = NULL;
  return temp;
}
inline void Response::set_allocated_intent(::svmp::Intent* intent) {
  delete intent_;
  intent_ = intent;
  if (intent) {
    set_has_intent();
  } else {
    clear_has_intent();
  }
}

// optional .svmp.Notification notification = 5;
inline bool Response::has_notification() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_notification() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_notification() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_notification() {
  if (notification_ != NULL) notification_->::svmp::Notification::Clear();
  clear_has_notification();
}
inline const ::svmp::Notification& Response::notification() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return notification_ != NULL ? *notification_ : *default_instance().notification_;
#else
  return notification_ != NULL ? *notification_ : *default_instance_->notification_;
#endif
}
inline ::svmp::Notification* Response::mutable_notification() {
  set_has_notification();
  if (notification_ == NULL) notification_ = new ::svmp::Notification;
  return notification_;
}
inline ::svmp::Notification* Response::release_notification() {
  clear_has_notification();
  ::svmp::Notification* temp = notification_;
  notification_ = NULL;
  return temp;
}
inline void Response::set_allocated_notification(::svmp::Notification* notification) {
  delete notification_;
  notification_ = notification;
  if (notification) {
    set_has_notification();
  } else {
    clear_has_notification();
  }
}

// optional .svmp.LocationResponse locationResponse = 6;
inline bool Response::has_locationresponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_locationresponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_locationresponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_locationresponse() {
  if (locationresponse_ != NULL) locationresponse_->::svmp::LocationResponse::Clear();
  clear_has_locationresponse();
}
inline const ::svmp::LocationResponse& Response::locationresponse() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return locationresponse_ != NULL ? *locationresponse_ : *default_instance().locationresponse_;
#else
  return locationresponse_ != NULL ? *locationresponse_ : *default_instance_->locationresponse_;
#endif
}
inline ::svmp::LocationResponse* Response::mutable_locationresponse() {
  set_has_locationresponse();
  if (locationresponse_ == NULL) locationresponse_ = new ::svmp::LocationResponse;
  return locationresponse_;
}
inline ::svmp::LocationResponse* Response::release_locationresponse() {
  clear_has_locationresponse();
  ::svmp::LocationResponse* temp = locationresponse_;
  locationresponse_ = NULL;
  return temp;
}
inline void Response::set_allocated_locationresponse(::svmp::LocationResponse* locationresponse) {
  delete locationresponse_;
  locationresponse_ = locationresponse;
  if (locationresponse) {
    set_has_locationresponse();
  } else {
    clear_has_locationresponse();
  }
}

// optional .svmp.ScreenInfo screen_info = 16;
inline bool Response::has_screen_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_screen_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_screen_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_screen_info() {
  if (screen_info_ != NULL) screen_info_->::svmp::ScreenInfo::Clear();
  clear_has_screen_info();
}
inline const ::svmp::ScreenInfo& Response::screen_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return screen_info_ != NULL ? *screen_info_ : *default_instance().screen_info_;
#else
  return screen_info_ != NULL ? *screen_info_ : *default_instance_->screen_info_;
#endif
}
inline ::svmp::ScreenInfo* Response::mutable_screen_info() {
  set_has_screen_info();
  if (screen_info_ == NULL) screen_info_ = new ::svmp::ScreenInfo;
  return screen_info_;
}
inline ::svmp::ScreenInfo* Response::release_screen_info() {
  clear_has_screen_info();
  ::svmp::ScreenInfo* temp = screen_info_;
  screen_info_ = NULL;
  return temp;
}
inline void Response::set_allocated_screen_info(::svmp::ScreenInfo* screen_info) {
  delete screen_info_;
  screen_info_ = screen_info;
  if (screen_info) {
    set_has_screen_info();
  } else {
    clear_has_screen_info();
  }
}

// optional .svmp.WebRTCMessage webrtcMsg = 17;
inline bool Response::has_webrtcmsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_webrtcmsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_webrtcmsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_webrtcmsg() {
  if (webrtcmsg_ != NULL) webrtcmsg_->::svmp::WebRTCMessage::Clear();
  clear_has_webrtcmsg();
}
inline const ::svmp::WebRTCMessage& Response::webrtcmsg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return webrtcmsg_ != NULL ? *webrtcmsg_ : *default_instance().webrtcmsg_;
#else
  return webrtcmsg_ != NULL ? *webrtcmsg_ : *default_instance_->webrtcmsg_;
#endif
}
inline ::svmp::WebRTCMessage* Response::mutable_webrtcmsg() {
  set_has_webrtcmsg();
  if (webrtcmsg_ == NULL) webrtcmsg_ = new ::svmp::WebRTCMessage;
  return webrtcmsg_;
}
inline ::svmp::WebRTCMessage* Response::release_webrtcmsg() {
  clear_has_webrtcmsg();
  ::svmp::WebRTCMessage* temp = webrtcmsg_;
  webrtcmsg_ = NULL;
  return temp;
}
inline void Response::set_allocated_webrtcmsg(::svmp::WebRTCMessage* webrtcmsg) {
  delete webrtcmsg_;
  webrtcmsg_ = webrtcmsg;
  if (webrtcmsg) {
    set_has_webrtcmsg();
  } else {
    clear_has_webrtcmsg();
  }
}

// -------------------------------------------------------------------

// Intent_Tuple

// required string key = 1;
inline bool Intent_Tuple::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Intent_Tuple::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Intent_Tuple::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Intent_Tuple::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Intent_Tuple::key() const {
  return *key_;
}
inline void Intent_Tuple::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Intent_Tuple::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Intent_Tuple::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intent_Tuple::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Intent_Tuple::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intent_Tuple::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool Intent_Tuple::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Intent_Tuple::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Intent_Tuple::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Intent_Tuple::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Intent_Tuple::value() const {
  return *value_;
}
inline void Intent_Tuple::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Intent_Tuple::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Intent_Tuple::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intent_Tuple::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Intent_Tuple::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intent_Tuple::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Intent

// required .svmp.IntentAction action = 1;
inline bool Intent::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Intent::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Intent::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Intent::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::svmp::IntentAction Intent::action() const {
  return static_cast< ::svmp::IntentAction >(action_);
}
inline void Intent::set_action(::svmp::IntentAction value) {
  assert(::svmp::IntentAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// repeated .svmp.Intent.Tuple extras = 2;
inline int Intent::extras_size() const {
  return extras_.size();
}
inline void Intent::clear_extras() {
  extras_.Clear();
}
inline const ::svmp::Intent_Tuple& Intent::extras(int index) const {
  return extras_.Get(index);
}
inline ::svmp::Intent_Tuple* Intent::mutable_extras(int index) {
  return extras_.Mutable(index);
}
inline ::svmp::Intent_Tuple* Intent::add_extras() {
  return extras_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::svmp::Intent_Tuple >&
Intent::extras() const {
  return extras_;
}
inline ::google::protobuf::RepeatedPtrField< ::svmp::Intent_Tuple >*
Intent::mutable_extras() {
  return &extras_;
}

// optional string data = 3;
inline bool Intent::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Intent::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Intent::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Intent::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Intent::data() const {
  return *data_;
}
inline void Intent::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Intent::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Intent::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intent::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Intent::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Intent::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 flags = 4;
inline int Intent::flags_size() const {
  return flags_.size();
}
inline void Intent::clear_flags() {
  flags_.Clear();
}
inline ::google::protobuf::int32 Intent::flags(int index) const {
  return flags_.Get(index);
}
inline void Intent::set_flags(int index, ::google::protobuf::int32 value) {
  flags_.Set(index, value);
}
inline void Intent::add_flags(::google::protobuf::int32 value) {
  flags_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Intent::flags() const {
  return flags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Intent::mutable_flags() {
  return &flags_;
}

// repeated string categories = 5;
inline int Intent::categories_size() const {
  return categories_.size();
}
inline void Intent::clear_categories() {
  categories_.Clear();
}
inline const ::std::string& Intent::categories(int index) const {
  return categories_.Get(index);
}
inline ::std::string* Intent::mutable_categories(int index) {
  return categories_.Mutable(index);
}
inline void Intent::set_categories(int index, const ::std::string& value) {
  categories_.Mutable(index)->assign(value);
}
inline void Intent::set_categories(int index, const char* value) {
  categories_.Mutable(index)->assign(value);
}
inline void Intent::set_categories(int index, const char* value, size_t size) {
  categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Intent::add_categories() {
  return categories_.Add();
}
inline void Intent::add_categories(const ::std::string& value) {
  categories_.Add()->assign(value);
}
inline void Intent::add_categories(const char* value) {
  categories_.Add()->assign(value);
}
inline void Intent::add_categories(const char* value, size_t size) {
  categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Intent::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Intent::mutable_categories() {
  return &categories_;
}

// -------------------------------------------------------------------

// Notification

// required string contentTitle = 1;
inline bool Notification::has_contenttitle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notification::set_has_contenttitle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notification::clear_has_contenttitle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notification::clear_contenttitle() {
  if (contenttitle_ != &::google::protobuf::internal::kEmptyString) {
    contenttitle_->clear();
  }
  clear_has_contenttitle();
}
inline const ::std::string& Notification::contenttitle() const {
  return *contenttitle_;
}
inline void Notification::set_contenttitle(const ::std::string& value) {
  set_has_contenttitle();
  if (contenttitle_ == &::google::protobuf::internal::kEmptyString) {
    contenttitle_ = new ::std::string;
  }
  contenttitle_->assign(value);
}
inline void Notification::set_contenttitle(const char* value) {
  set_has_contenttitle();
  if (contenttitle_ == &::google::protobuf::internal::kEmptyString) {
    contenttitle_ = new ::std::string;
  }
  contenttitle_->assign(value);
}
inline void Notification::set_contenttitle(const char* value, size_t size) {
  set_has_contenttitle();
  if (contenttitle_ == &::google::protobuf::internal::kEmptyString) {
    contenttitle_ = new ::std::string;
  }
  contenttitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_contenttitle() {
  set_has_contenttitle();
  if (contenttitle_ == &::google::protobuf::internal::kEmptyString) {
    contenttitle_ = new ::std::string;
  }
  return contenttitle_;
}
inline ::std::string* Notification::release_contenttitle() {
  clear_has_contenttitle();
  if (contenttitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contenttitle_;
    contenttitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_contenttitle(::std::string* contenttitle) {
  if (contenttitle_ != &::google::protobuf::internal::kEmptyString) {
    delete contenttitle_;
  }
  if (contenttitle) {
    set_has_contenttitle();
    contenttitle_ = contenttitle;
  } else {
    clear_has_contenttitle();
    contenttitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string contentText = 2;
inline bool Notification::has_contenttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notification::set_has_contenttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notification::clear_has_contenttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notification::clear_contenttext() {
  if (contenttext_ != &::google::protobuf::internal::kEmptyString) {
    contenttext_->clear();
  }
  clear_has_contenttext();
}
inline const ::std::string& Notification::contenttext() const {
  return *contenttext_;
}
inline void Notification::set_contenttext(const ::std::string& value) {
  set_has_contenttext();
  if (contenttext_ == &::google::protobuf::internal::kEmptyString) {
    contenttext_ = new ::std::string;
  }
  contenttext_->assign(value);
}
inline void Notification::set_contenttext(const char* value) {
  set_has_contenttext();
  if (contenttext_ == &::google::protobuf::internal::kEmptyString) {
    contenttext_ = new ::std::string;
  }
  contenttext_->assign(value);
}
inline void Notification::set_contenttext(const char* value, size_t size) {
  set_has_contenttext();
  if (contenttext_ == &::google::protobuf::internal::kEmptyString) {
    contenttext_ = new ::std::string;
  }
  contenttext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_contenttext() {
  set_has_contenttext();
  if (contenttext_ == &::google::protobuf::internal::kEmptyString) {
    contenttext_ = new ::std::string;
  }
  return contenttext_;
}
inline ::std::string* Notification::release_contenttext() {
  clear_has_contenttext();
  if (contenttext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contenttext_;
    contenttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_contenttext(::std::string* contenttext) {
  if (contenttext_ != &::google::protobuf::internal::kEmptyString) {
    delete contenttext_;
  }
  if (contenttext) {
    set_has_contenttext();
    contenttext_ = contenttext;
  } else {
    clear_has_contenttext();
    contenttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes smallIcon = 3;
inline bool Notification::has_smallicon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notification::set_has_smallicon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notification::clear_has_smallicon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notification::clear_smallicon() {
  if (smallicon_ != &::google::protobuf::internal::kEmptyString) {
    smallicon_->clear();
  }
  clear_has_smallicon();
}
inline const ::std::string& Notification::smallicon() const {
  return *smallicon_;
}
inline void Notification::set_smallicon(const ::std::string& value) {
  set_has_smallicon();
  if (smallicon_ == &::google::protobuf::internal::kEmptyString) {
    smallicon_ = new ::std::string;
  }
  smallicon_->assign(value);
}
inline void Notification::set_smallicon(const char* value) {
  set_has_smallicon();
  if (smallicon_ == &::google::protobuf::internal::kEmptyString) {
    smallicon_ = new ::std::string;
  }
  smallicon_->assign(value);
}
inline void Notification::set_smallicon(const void* value, size_t size) {
  set_has_smallicon();
  if (smallicon_ == &::google::protobuf::internal::kEmptyString) {
    smallicon_ = new ::std::string;
  }
  smallicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_smallicon() {
  set_has_smallicon();
  if (smallicon_ == &::google::protobuf::internal::kEmptyString) {
    smallicon_ = new ::std::string;
  }
  return smallicon_;
}
inline ::std::string* Notification::release_smallicon() {
  clear_has_smallicon();
  if (smallicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = smallicon_;
    smallicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_smallicon(::std::string* smallicon) {
  if (smallicon_ != &::google::protobuf::internal::kEmptyString) {
    delete smallicon_;
  }
  if (smallicon) {
    set_has_smallicon();
    smallicon_ = smallicon;
  } else {
    clear_has_smallicon();
    smallicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes largeIcon = 4;
inline bool Notification::has_largeicon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Notification::set_has_largeicon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Notification::clear_has_largeicon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Notification::clear_largeicon() {
  if (largeicon_ != &::google::protobuf::internal::kEmptyString) {
    largeicon_->clear();
  }
  clear_has_largeicon();
}
inline const ::std::string& Notification::largeicon() const {
  return *largeicon_;
}
inline void Notification::set_largeicon(const ::std::string& value) {
  set_has_largeicon();
  if (largeicon_ == &::google::protobuf::internal::kEmptyString) {
    largeicon_ = new ::std::string;
  }
  largeicon_->assign(value);
}
inline void Notification::set_largeicon(const char* value) {
  set_has_largeicon();
  if (largeicon_ == &::google::protobuf::internal::kEmptyString) {
    largeicon_ = new ::std::string;
  }
  largeicon_->assign(value);
}
inline void Notification::set_largeicon(const void* value, size_t size) {
  set_has_largeicon();
  if (largeicon_ == &::google::protobuf::internal::kEmptyString) {
    largeicon_ = new ::std::string;
  }
  largeicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_largeicon() {
  set_has_largeicon();
  if (largeicon_ == &::google::protobuf::internal::kEmptyString) {
    largeicon_ = new ::std::string;
  }
  return largeicon_;
}
inline ::std::string* Notification::release_largeicon() {
  clear_has_largeicon();
  if (largeicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = largeicon_;
    largeicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_largeicon(::std::string* largeicon) {
  if (largeicon_ != &::google::protobuf::internal::kEmptyString) {
    delete largeicon_;
  }
  if (largeicon) {
    set_has_largeicon();
    largeicon_ = largeicon;
  } else {
    clear_has_largeicon();
    largeicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TouchEvent_PointerCoords

// required int32 id = 1;
inline bool TouchEvent_PointerCoords::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TouchEvent_PointerCoords::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TouchEvent_PointerCoords::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TouchEvent_PointerCoords::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TouchEvent_PointerCoords::id() const {
  return id_;
}
inline void TouchEvent_PointerCoords::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required float x = 2;
inline bool TouchEvent_PointerCoords::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TouchEvent_PointerCoords::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TouchEvent_PointerCoords::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TouchEvent_PointerCoords::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float TouchEvent_PointerCoords::x() const {
  return x_;
}
inline void TouchEvent_PointerCoords::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 3;
inline bool TouchEvent_PointerCoords::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TouchEvent_PointerCoords::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TouchEvent_PointerCoords::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TouchEvent_PointerCoords::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float TouchEvent_PointerCoords::y() const {
  return y_;
}
inline void TouchEvent_PointerCoords::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// TouchEvent

// required int32 action = 1;
inline bool TouchEvent::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TouchEvent::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TouchEvent::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TouchEvent::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 TouchEvent::action() const {
  return action_;
}
inline void TouchEvent::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// repeated .svmp.TouchEvent.PointerCoords items = 2;
inline int TouchEvent::items_size() const {
  return items_.size();
}
inline void TouchEvent::clear_items() {
  items_.Clear();
}
inline const ::svmp::TouchEvent_PointerCoords& TouchEvent::items(int index) const {
  return items_.Get(index);
}
inline ::svmp::TouchEvent_PointerCoords* TouchEvent::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::svmp::TouchEvent_PointerCoords* TouchEvent::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::svmp::TouchEvent_PointerCoords >&
TouchEvent::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::svmp::TouchEvent_PointerCoords >*
TouchEvent::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// ScreenInfo

// required int32 x = 1;
inline bool ScreenInfo::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScreenInfo::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScreenInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScreenInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 ScreenInfo::x() const {
  return x_;
}
inline void ScreenInfo::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool ScreenInfo::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScreenInfo::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScreenInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScreenInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 ScreenInfo::y() const {
  return y_;
}
inline void ScreenInfo::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// SensorEvent

// required .svmp.SensorType type = 1;
inline bool SensorEvent::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorEvent::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorEvent::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::svmp::SensorType SensorEvent::type() const {
  return static_cast< ::svmp::SensorType >(type_);
}
inline void SensorEvent::set_type(::svmp::SensorType value) {
  assert(::svmp::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required int32 accuracy = 2;
inline bool SensorEvent::has_accuracy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorEvent::set_has_accuracy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorEvent::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorEvent::clear_accuracy() {
  accuracy_ = 0;
  clear_has_accuracy();
}
inline ::google::protobuf::int32 SensorEvent::accuracy() const {
  return accuracy_;
}
inline void SensorEvent::set_accuracy(::google::protobuf::int32 value) {
  set_has_accuracy();
  accuracy_ = value;
}

// required int64 timestamp = 3;
inline bool SensorEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorEvent::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 SensorEvent::timestamp() const {
  return timestamp_;
}
inline void SensorEvent::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// repeated float values = 4;
inline int SensorEvent::values_size() const {
  return values_.size();
}
inline void SensorEvent::clear_values() {
  values_.Clear();
}
inline float SensorEvent::values(int index) const {
  return values_.Get(index);
}
inline void SensorEvent::set_values(int index, float value) {
  values_.Set(index, value);
}
inline void SensorEvent::add_values(float value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SensorEvent::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< float >*
SensorEvent::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// SensorSubscribe

// required .svmp.SensorType type = 1;
inline bool SensorSubscribe::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorSubscribe::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorSubscribe::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorSubscribe::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::svmp::SensorType SensorSubscribe::type() const {
  return static_cast< ::svmp::SensorType >(type_);
}
inline void SensorSubscribe::set_type(::svmp::SensorType value) {
  assert(::svmp::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 frequency = 2;
inline bool SensorSubscribe::has_frequency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorSubscribe::set_has_frequency() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorSubscribe::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorSubscribe::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline ::google::protobuf::int32 SensorSubscribe::frequency() const {
  return frequency_;
}
inline void SensorSubscribe::set_frequency(::google::protobuf::int32 value) {
  set_has_frequency();
  frequency_ = value;
}

// -------------------------------------------------------------------

// SensorUnsubscribe

// required .svmp.SensorType type = 1;
inline bool SensorUnsubscribe::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorUnsubscribe::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorUnsubscribe::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorUnsubscribe::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::svmp::SensorType SensorUnsubscribe::type() const {
  return static_cast< ::svmp::SensorType >(type_);
}
inline void SensorUnsubscribe::set_type(::svmp::SensorType value) {
  assert(::svmp::SensorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// LocationProviderInfo

// required string provider = 1;
inline bool LocationProviderInfo::has_provider() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationProviderInfo::set_has_provider() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationProviderInfo::clear_has_provider() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationProviderInfo::clear_provider() {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    provider_->clear();
  }
  clear_has_provider();
}
inline const ::std::string& LocationProviderInfo::provider() const {
  return *provider_;
}
inline void LocationProviderInfo::set_provider(const ::std::string& value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationProviderInfo::set_provider(const char* value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationProviderInfo::set_provider(const char* value, size_t size) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationProviderInfo::mutable_provider() {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  return provider_;
}
inline ::std::string* LocationProviderInfo::release_provider() {
  clear_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_;
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocationProviderInfo::set_allocated_provider(::std::string* provider) {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_;
  }
  if (provider) {
    set_has_provider();
    provider_ = provider;
  } else {
    clear_has_provider();
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool requiresNetwork = 2;
inline bool LocationProviderInfo::has_requiresnetwork() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationProviderInfo::set_has_requiresnetwork() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationProviderInfo::clear_has_requiresnetwork() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationProviderInfo::clear_requiresnetwork() {
  requiresnetwork_ = false;
  clear_has_requiresnetwork();
}
inline bool LocationProviderInfo::requiresnetwork() const {
  return requiresnetwork_;
}
inline void LocationProviderInfo::set_requiresnetwork(bool value) {
  set_has_requiresnetwork();
  requiresnetwork_ = value;
}

// required bool requiresSatellite = 3;
inline bool LocationProviderInfo::has_requiressatellite() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationProviderInfo::set_has_requiressatellite() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationProviderInfo::clear_has_requiressatellite() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationProviderInfo::clear_requiressatellite() {
  requiressatellite_ = false;
  clear_has_requiressatellite();
}
inline bool LocationProviderInfo::requiressatellite() const {
  return requiressatellite_;
}
inline void LocationProviderInfo::set_requiressatellite(bool value) {
  set_has_requiressatellite();
  requiressatellite_ = value;
}

// required bool requiresCell = 4;
inline bool LocationProviderInfo::has_requirescell() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationProviderInfo::set_has_requirescell() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationProviderInfo::clear_has_requirescell() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationProviderInfo::clear_requirescell() {
  requirescell_ = false;
  clear_has_requirescell();
}
inline bool LocationProviderInfo::requirescell() const {
  return requirescell_;
}
inline void LocationProviderInfo::set_requirescell(bool value) {
  set_has_requirescell();
  requirescell_ = value;
}

// required bool hasMonetaryCost = 5;
inline bool LocationProviderInfo::has_hasmonetarycost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocationProviderInfo::set_has_hasmonetarycost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocationProviderInfo::clear_has_hasmonetarycost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocationProviderInfo::clear_hasmonetarycost() {
  hasmonetarycost_ = false;
  clear_has_hasmonetarycost();
}
inline bool LocationProviderInfo::hasmonetarycost() const {
  return hasmonetarycost_;
}
inline void LocationProviderInfo::set_hasmonetarycost(bool value) {
  set_has_hasmonetarycost();
  hasmonetarycost_ = value;
}

// required bool supportsAltitude = 6;
inline bool LocationProviderInfo::has_supportsaltitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocationProviderInfo::set_has_supportsaltitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocationProviderInfo::clear_has_supportsaltitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocationProviderInfo::clear_supportsaltitude() {
  supportsaltitude_ = false;
  clear_has_supportsaltitude();
}
inline bool LocationProviderInfo::supportsaltitude() const {
  return supportsaltitude_;
}
inline void LocationProviderInfo::set_supportsaltitude(bool value) {
  set_has_supportsaltitude();
  supportsaltitude_ = value;
}

// required bool supportsSpeed = 7;
inline bool LocationProviderInfo::has_supportsspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LocationProviderInfo::set_has_supportsspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LocationProviderInfo::clear_has_supportsspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LocationProviderInfo::clear_supportsspeed() {
  supportsspeed_ = false;
  clear_has_supportsspeed();
}
inline bool LocationProviderInfo::supportsspeed() const {
  return supportsspeed_;
}
inline void LocationProviderInfo::set_supportsspeed(bool value) {
  set_has_supportsspeed();
  supportsspeed_ = value;
}

// required bool supportsBearing = 8;
inline bool LocationProviderInfo::has_supportsbearing() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LocationProviderInfo::set_has_supportsbearing() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LocationProviderInfo::clear_has_supportsbearing() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LocationProviderInfo::clear_supportsbearing() {
  supportsbearing_ = false;
  clear_has_supportsbearing();
}
inline bool LocationProviderInfo::supportsbearing() const {
  return supportsbearing_;
}
inline void LocationProviderInfo::set_supportsbearing(bool value) {
  set_has_supportsbearing();
  supportsbearing_ = value;
}

// required int32 powerRequirement = 9;
inline bool LocationProviderInfo::has_powerrequirement() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LocationProviderInfo::set_has_powerrequirement() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LocationProviderInfo::clear_has_powerrequirement() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LocationProviderInfo::clear_powerrequirement() {
  powerrequirement_ = 0;
  clear_has_powerrequirement();
}
inline ::google::protobuf::int32 LocationProviderInfo::powerrequirement() const {
  return powerrequirement_;
}
inline void LocationProviderInfo::set_powerrequirement(::google::protobuf::int32 value) {
  set_has_powerrequirement();
  powerrequirement_ = value;
}

// required int32 accuracy = 10;
inline bool LocationProviderInfo::has_accuracy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LocationProviderInfo::set_has_accuracy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LocationProviderInfo::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LocationProviderInfo::clear_accuracy() {
  accuracy_ = 0;
  clear_has_accuracy();
}
inline ::google::protobuf::int32 LocationProviderInfo::accuracy() const {
  return accuracy_;
}
inline void LocationProviderInfo::set_accuracy(::google::protobuf::int32 value) {
  set_has_accuracy();
  accuracy_ = value;
}

// -------------------------------------------------------------------

// LocationProviderStatus_Tuple

// required string key = 1;
inline bool LocationProviderStatus_Tuple::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationProviderStatus_Tuple::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationProviderStatus_Tuple::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationProviderStatus_Tuple::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& LocationProviderStatus_Tuple::key() const {
  return *key_;
}
inline void LocationProviderStatus_Tuple::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LocationProviderStatus_Tuple::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LocationProviderStatus_Tuple::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationProviderStatus_Tuple::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* LocationProviderStatus_Tuple::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocationProviderStatus_Tuple::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool LocationProviderStatus_Tuple::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationProviderStatus_Tuple::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationProviderStatus_Tuple::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationProviderStatus_Tuple::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& LocationProviderStatus_Tuple::value() const {
  return *value_;
}
inline void LocationProviderStatus_Tuple::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void LocationProviderStatus_Tuple::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void LocationProviderStatus_Tuple::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationProviderStatus_Tuple::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* LocationProviderStatus_Tuple::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocationProviderStatus_Tuple::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LocationProviderStatus

// required string provider = 1;
inline bool LocationProviderStatus::has_provider() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationProviderStatus::set_has_provider() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationProviderStatus::clear_has_provider() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationProviderStatus::clear_provider() {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    provider_->clear();
  }
  clear_has_provider();
}
inline const ::std::string& LocationProviderStatus::provider() const {
  return *provider_;
}
inline void LocationProviderStatus::set_provider(const ::std::string& value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationProviderStatus::set_provider(const char* value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationProviderStatus::set_provider(const char* value, size_t size) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationProviderStatus::mutable_provider() {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  return provider_;
}
inline ::std::string* LocationProviderStatus::release_provider() {
  clear_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_;
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocationProviderStatus::set_allocated_provider(::std::string* provider) {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_;
  }
  if (provider) {
    set_has_provider();
    provider_ = provider;
  } else {
    clear_has_provider();
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 2;
inline bool LocationProviderStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationProviderStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationProviderStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationProviderStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 LocationProviderStatus::status() const {
  return status_;
}
inline void LocationProviderStatus::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated .svmp.LocationProviderStatus.Tuple extras = 3;
inline int LocationProviderStatus::extras_size() const {
  return extras_.size();
}
inline void LocationProviderStatus::clear_extras() {
  extras_.Clear();
}
inline const ::svmp::LocationProviderStatus_Tuple& LocationProviderStatus::extras(int index) const {
  return extras_.Get(index);
}
inline ::svmp::LocationProviderStatus_Tuple* LocationProviderStatus::mutable_extras(int index) {
  return extras_.Mutable(index);
}
inline ::svmp::LocationProviderStatus_Tuple* LocationProviderStatus::add_extras() {
  return extras_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::svmp::LocationProviderStatus_Tuple >&
LocationProviderStatus::extras() const {
  return extras_;
}
inline ::google::protobuf::RepeatedPtrField< ::svmp::LocationProviderStatus_Tuple >*
LocationProviderStatus::mutable_extras() {
  return &extras_;
}

// -------------------------------------------------------------------

// LocationProviderEnabled

// required string provider = 1;
inline bool LocationProviderEnabled::has_provider() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationProviderEnabled::set_has_provider() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationProviderEnabled::clear_has_provider() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationProviderEnabled::clear_provider() {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    provider_->clear();
  }
  clear_has_provider();
}
inline const ::std::string& LocationProviderEnabled::provider() const {
  return *provider_;
}
inline void LocationProviderEnabled::set_provider(const ::std::string& value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationProviderEnabled::set_provider(const char* value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationProviderEnabled::set_provider(const char* value, size_t size) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationProviderEnabled::mutable_provider() {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  return provider_;
}
inline ::std::string* LocationProviderEnabled::release_provider() {
  clear_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_;
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocationProviderEnabled::set_allocated_provider(::std::string* provider) {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_;
  }
  if (provider) {
    set_has_provider();
    provider_ = provider;
  } else {
    clear_has_provider();
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool enabled = 2;
inline bool LocationProviderEnabled::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationProviderEnabled::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationProviderEnabled::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationProviderEnabled::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool LocationProviderEnabled::enabled() const {
  return enabled_;
}
inline void LocationProviderEnabled::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// LocationUpdate

// required double latitude = 1;
inline bool LocationUpdate::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationUpdate::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationUpdate::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationUpdate::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double LocationUpdate::latitude() const {
  return latitude_;
}
inline void LocationUpdate::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// required double longitude = 2;
inline bool LocationUpdate::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationUpdate::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationUpdate::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationUpdate::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double LocationUpdate::longitude() const {
  return longitude_;
}
inline void LocationUpdate::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// required int64 time = 3;
inline bool LocationUpdate::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationUpdate::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationUpdate::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationUpdate::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 LocationUpdate::time() const {
  return time_;
}
inline void LocationUpdate::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string provider = 4;
inline bool LocationUpdate::has_provider() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationUpdate::set_has_provider() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationUpdate::clear_has_provider() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationUpdate::clear_provider() {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    provider_->clear();
  }
  clear_has_provider();
}
inline const ::std::string& LocationUpdate::provider() const {
  return *provider_;
}
inline void LocationUpdate::set_provider(const ::std::string& value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationUpdate::set_provider(const char* value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationUpdate::set_provider(const char* value, size_t size) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationUpdate::mutable_provider() {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  return provider_;
}
inline ::std::string* LocationUpdate::release_provider() {
  clear_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_;
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocationUpdate::set_allocated_provider(::std::string* provider) {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_;
  }
  if (provider) {
    set_has_provider();
    provider_ = provider;
  } else {
    clear_has_provider();
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float accuracy = 5;
inline bool LocationUpdate::has_accuracy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocationUpdate::set_has_accuracy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocationUpdate::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocationUpdate::clear_accuracy() {
  accuracy_ = 0;
  clear_has_accuracy();
}
inline float LocationUpdate::accuracy() const {
  return accuracy_;
}
inline void LocationUpdate::set_accuracy(float value) {
  set_has_accuracy();
  accuracy_ = value;
}

// optional double altitude = 6;
inline bool LocationUpdate::has_altitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocationUpdate::set_has_altitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocationUpdate::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocationUpdate::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double LocationUpdate::altitude() const {
  return altitude_;
}
inline void LocationUpdate::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
}

// optional float bearing = 7;
inline bool LocationUpdate::has_bearing() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LocationUpdate::set_has_bearing() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LocationUpdate::clear_has_bearing() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LocationUpdate::clear_bearing() {
  bearing_ = 0;
  clear_has_bearing();
}
inline float LocationUpdate::bearing() const {
  return bearing_;
}
inline void LocationUpdate::set_bearing(float value) {
  set_has_bearing();
  bearing_ = value;
}

// optional float speed = 8;
inline bool LocationUpdate::has_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LocationUpdate::set_has_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LocationUpdate::clear_has_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LocationUpdate::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float LocationUpdate::speed() const {
  return speed_;
}
inline void LocationUpdate::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// LocationRequest

// required .svmp.LocationRequest.LocationRequestType type = 1;
inline bool LocationRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::svmp::LocationRequest_LocationRequestType LocationRequest::type() const {
  return static_cast< ::svmp::LocationRequest_LocationRequestType >(type_);
}
inline void LocationRequest::set_type(::svmp::LocationRequest_LocationRequestType value) {
  assert(::svmp::LocationRequest_LocationRequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .svmp.LocationProviderInfo providerInfo = 2;
inline bool LocationRequest::has_providerinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationRequest::set_has_providerinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationRequest::clear_has_providerinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationRequest::clear_providerinfo() {
  if (providerinfo_ != NULL) providerinfo_->::svmp::LocationProviderInfo::Clear();
  clear_has_providerinfo();
}
inline const ::svmp::LocationProviderInfo& LocationRequest::providerinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return providerinfo_ != NULL ? *providerinfo_ : *default_instance().providerinfo_;
#else
  return providerinfo_ != NULL ? *providerinfo_ : *default_instance_->providerinfo_;
#endif
}
inline ::svmp::LocationProviderInfo* LocationRequest::mutable_providerinfo() {
  set_has_providerinfo();
  if (providerinfo_ == NULL) providerinfo_ = new ::svmp::LocationProviderInfo;
  return providerinfo_;
}
inline ::svmp::LocationProviderInfo* LocationRequest::release_providerinfo() {
  clear_has_providerinfo();
  ::svmp::LocationProviderInfo* temp = providerinfo_;
  providerinfo_ = NULL;
  return temp;
}
inline void LocationRequest::set_allocated_providerinfo(::svmp::LocationProviderInfo* providerinfo) {
  delete providerinfo_;
  providerinfo_ = providerinfo;
  if (providerinfo) {
    set_has_providerinfo();
  } else {
    clear_has_providerinfo();
  }
}

// optional .svmp.LocationProviderStatus providerStatus = 3;
inline bool LocationRequest::has_providerstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationRequest::set_has_providerstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationRequest::clear_has_providerstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationRequest::clear_providerstatus() {
  if (providerstatus_ != NULL) providerstatus_->::svmp::LocationProviderStatus::Clear();
  clear_has_providerstatus();
}
inline const ::svmp::LocationProviderStatus& LocationRequest::providerstatus() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return providerstatus_ != NULL ? *providerstatus_ : *default_instance().providerstatus_;
#else
  return providerstatus_ != NULL ? *providerstatus_ : *default_instance_->providerstatus_;
#endif
}
inline ::svmp::LocationProviderStatus* LocationRequest::mutable_providerstatus() {
  set_has_providerstatus();
  if (providerstatus_ == NULL) providerstatus_ = new ::svmp::LocationProviderStatus;
  return providerstatus_;
}
inline ::svmp::LocationProviderStatus* LocationRequest::release_providerstatus() {
  clear_has_providerstatus();
  ::svmp::LocationProviderStatus* temp = providerstatus_;
  providerstatus_ = NULL;
  return temp;
}
inline void LocationRequest::set_allocated_providerstatus(::svmp::LocationProviderStatus* providerstatus) {
  delete providerstatus_;
  providerstatus_ = providerstatus;
  if (providerstatus) {
    set_has_providerstatus();
  } else {
    clear_has_providerstatus();
  }
}

// optional .svmp.LocationProviderEnabled providerEnabled = 4;
inline bool LocationRequest::has_providerenabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationRequest::set_has_providerenabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationRequest::clear_has_providerenabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationRequest::clear_providerenabled() {
  if (providerenabled_ != NULL) providerenabled_->::svmp::LocationProviderEnabled::Clear();
  clear_has_providerenabled();
}
inline const ::svmp::LocationProviderEnabled& LocationRequest::providerenabled() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return providerenabled_ != NULL ? *providerenabled_ : *default_instance().providerenabled_;
#else
  return providerenabled_ != NULL ? *providerenabled_ : *default_instance_->providerenabled_;
#endif
}
inline ::svmp::LocationProviderEnabled* LocationRequest::mutable_providerenabled() {
  set_has_providerenabled();
  if (providerenabled_ == NULL) providerenabled_ = new ::svmp::LocationProviderEnabled;
  return providerenabled_;
}
inline ::svmp::LocationProviderEnabled* LocationRequest::release_providerenabled() {
  clear_has_providerenabled();
  ::svmp::LocationProviderEnabled* temp = providerenabled_;
  providerenabled_ = NULL;
  return temp;
}
inline void LocationRequest::set_allocated_providerenabled(::svmp::LocationProviderEnabled* providerenabled) {
  delete providerenabled_;
  providerenabled_ = providerenabled;
  if (providerenabled) {
    set_has_providerenabled();
  } else {
    clear_has_providerenabled();
  }
}

// optional .svmp.LocationUpdate update = 5;
inline bool LocationRequest::has_update() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocationRequest::set_has_update() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocationRequest::clear_has_update() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocationRequest::clear_update() {
  if (update_ != NULL) update_->::svmp::LocationUpdate::Clear();
  clear_has_update();
}
inline const ::svmp::LocationUpdate& LocationRequest::update() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return update_ != NULL ? *update_ : *default_instance().update_;
#else
  return update_ != NULL ? *update_ : *default_instance_->update_;
#endif
}
inline ::svmp::LocationUpdate* LocationRequest::mutable_update() {
  set_has_update();
  if (update_ == NULL) update_ = new ::svmp::LocationUpdate;
  return update_;
}
inline ::svmp::LocationUpdate* LocationRequest::release_update() {
  clear_has_update();
  ::svmp::LocationUpdate* temp = update_;
  update_ = NULL;
  return temp;
}
inline void LocationRequest::set_allocated_update(::svmp::LocationUpdate* update) {
  delete update_;
  update_ = update;
  if (update) {
    set_has_update();
  } else {
    clear_has_update();
  }
}

// -------------------------------------------------------------------

// LocationSubscribe

// required .svmp.LocationSubscribe.LocationSubscribeType type = 1;
inline bool LocationSubscribe::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationSubscribe::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationSubscribe::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationSubscribe::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::svmp::LocationSubscribe_LocationSubscribeType LocationSubscribe::type() const {
  return static_cast< ::svmp::LocationSubscribe_LocationSubscribeType >(type_);
}
inline void LocationSubscribe::set_type(::svmp::LocationSubscribe_LocationSubscribeType value) {
  assert(::svmp::LocationSubscribe_LocationSubscribeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string provider = 2;
inline bool LocationSubscribe::has_provider() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationSubscribe::set_has_provider() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationSubscribe::clear_has_provider() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationSubscribe::clear_provider() {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    provider_->clear();
  }
  clear_has_provider();
}
inline const ::std::string& LocationSubscribe::provider() const {
  return *provider_;
}
inline void LocationSubscribe::set_provider(const ::std::string& value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationSubscribe::set_provider(const char* value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationSubscribe::set_provider(const char* value, size_t size) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationSubscribe::mutable_provider() {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  return provider_;
}
inline ::std::string* LocationSubscribe::release_provider() {
  clear_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_;
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocationSubscribe::set_allocated_provider(::std::string* provider) {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_;
  }
  if (provider) {
    set_has_provider();
    provider_ = provider;
  } else {
    clear_has_provider();
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 minTime = 3;
inline bool LocationSubscribe::has_mintime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationSubscribe::set_has_mintime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationSubscribe::clear_has_mintime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationSubscribe::clear_mintime() {
  mintime_ = GOOGLE_LONGLONG(0);
  clear_has_mintime();
}
inline ::google::protobuf::int64 LocationSubscribe::mintime() const {
  return mintime_;
}
inline void LocationSubscribe::set_mintime(::google::protobuf::int64 value) {
  set_has_mintime();
  mintime_ = value;
}

// optional float minDistance = 4;
inline bool LocationSubscribe::has_mindistance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocationSubscribe::set_has_mindistance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocationSubscribe::clear_has_mindistance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocationSubscribe::clear_mindistance() {
  mindistance_ = 0;
  clear_has_mindistance();
}
inline float LocationSubscribe::mindistance() const {
  return mindistance_;
}
inline void LocationSubscribe::set_mindistance(float value) {
  set_has_mindistance();
  mindistance_ = value;
}

// -------------------------------------------------------------------

// LocationUnsubscribe

// required string provider = 1;
inline bool LocationUnsubscribe::has_provider() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationUnsubscribe::set_has_provider() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationUnsubscribe::clear_has_provider() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationUnsubscribe::clear_provider() {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    provider_->clear();
  }
  clear_has_provider();
}
inline const ::std::string& LocationUnsubscribe::provider() const {
  return *provider_;
}
inline void LocationUnsubscribe::set_provider(const ::std::string& value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationUnsubscribe::set_provider(const char* value) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(value);
}
inline void LocationUnsubscribe::set_provider(const char* value, size_t size) {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  provider_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationUnsubscribe::mutable_provider() {
  set_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    provider_ = new ::std::string;
  }
  return provider_;
}
inline ::std::string* LocationUnsubscribe::release_provider() {
  clear_has_provider();
  if (provider_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = provider_;
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocationUnsubscribe::set_allocated_provider(::std::string* provider) {
  if (provider_ != &::google::protobuf::internal::kEmptyString) {
    delete provider_;
  }
  if (provider) {
    set_has_provider();
    provider_ = provider;
  } else {
    clear_has_provider();
    provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LocationResponse

// required .svmp.LocationResponse.LocationResponseType type = 1;
inline bool LocationResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::svmp::LocationResponse_LocationResponseType LocationResponse::type() const {
  return static_cast< ::svmp::LocationResponse_LocationResponseType >(type_);
}
inline void LocationResponse::set_type(::svmp::LocationResponse_LocationResponseType value) {
  assert(::svmp::LocationResponse_LocationResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .svmp.LocationSubscribe subscribe = 2;
inline bool LocationResponse::has_subscribe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationResponse::set_has_subscribe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationResponse::clear_has_subscribe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationResponse::clear_subscribe() {
  if (subscribe_ != NULL) subscribe_->::svmp::LocationSubscribe::Clear();
  clear_has_subscribe();
}
inline const ::svmp::LocationSubscribe& LocationResponse::subscribe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return subscribe_ != NULL ? *subscribe_ : *default_instance().subscribe_;
#else
  return subscribe_ != NULL ? *subscribe_ : *default_instance_->subscribe_;
#endif
}
inline ::svmp::LocationSubscribe* LocationResponse::mutable_subscribe() {
  set_has_subscribe();
  if (subscribe_ == NULL) subscribe_ = new ::svmp::LocationSubscribe;
  return subscribe_;
}
inline ::svmp::LocationSubscribe* LocationResponse::release_subscribe() {
  clear_has_subscribe();
  ::svmp::LocationSubscribe* temp = subscribe_;
  subscribe_ = NULL;
  return temp;
}
inline void LocationResponse::set_allocated_subscribe(::svmp::LocationSubscribe* subscribe) {
  delete subscribe_;
  subscribe_ = subscribe;
  if (subscribe) {
    set_has_subscribe();
  } else {
    clear_has_subscribe();
  }
}

// optional .svmp.LocationUnsubscribe unsubscribe = 3;
inline bool LocationResponse::has_unsubscribe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationResponse::set_has_unsubscribe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationResponse::clear_has_unsubscribe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationResponse::clear_unsubscribe() {
  if (unsubscribe_ != NULL) unsubscribe_->::svmp::LocationUnsubscribe::Clear();
  clear_has_unsubscribe();
}
inline const ::svmp::LocationUnsubscribe& LocationResponse::unsubscribe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return unsubscribe_ != NULL ? *unsubscribe_ : *default_instance().unsubscribe_;
#else
  return unsubscribe_ != NULL ? *unsubscribe_ : *default_instance_->unsubscribe_;
#endif
}
inline ::svmp::LocationUnsubscribe* LocationResponse::mutable_unsubscribe() {
  set_has_unsubscribe();
  if (unsubscribe_ == NULL) unsubscribe_ = new ::svmp::LocationUnsubscribe;
  return unsubscribe_;
}
inline ::svmp::LocationUnsubscribe* LocationResponse::release_unsubscribe() {
  clear_has_unsubscribe();
  ::svmp::LocationUnsubscribe* temp = unsubscribe_;
  unsubscribe_ = NULL;
  return temp;
}
inline void LocationResponse::set_allocated_unsubscribe(::svmp::LocationUnsubscribe* unsubscribe) {
  delete unsubscribe_;
  unsubscribe_ = unsubscribe;
  if (unsubscribe) {
    set_has_unsubscribe();
  } else {
    clear_has_unsubscribe();
  }
}

// -------------------------------------------------------------------

// Authentication

// required string un = 1;
inline bool Authentication::has_un() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authentication::set_has_un() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authentication::clear_has_un() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authentication::clear_un() {
  if (un_ != &::google::protobuf::internal::kEmptyString) {
    un_->clear();
  }
  clear_has_un();
}
inline const ::std::string& Authentication::un() const {
  return *un_;
}
inline void Authentication::set_un(const ::std::string& value) {
  set_has_un();
  if (un_ == &::google::protobuf::internal::kEmptyString) {
    un_ = new ::std::string;
  }
  un_->assign(value);
}
inline void Authentication::set_un(const char* value) {
  set_has_un();
  if (un_ == &::google::protobuf::internal::kEmptyString) {
    un_ = new ::std::string;
  }
  un_->assign(value);
}
inline void Authentication::set_un(const char* value, size_t size) {
  set_has_un();
  if (un_ == &::google::protobuf::internal::kEmptyString) {
    un_ = new ::std::string;
  }
  un_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Authentication::mutable_un() {
  set_has_un();
  if (un_ == &::google::protobuf::internal::kEmptyString) {
    un_ = new ::std::string;
  }
  return un_;
}
inline ::std::string* Authentication::release_un() {
  clear_has_un();
  if (un_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = un_;
    un_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Authentication::set_allocated_un(::std::string* un) {
  if (un_ != &::google::protobuf::internal::kEmptyString) {
    delete un_;
  }
  if (un) {
    set_has_un();
    un_ = un;
  } else {
    clear_has_un();
    un_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string pw = 2;
inline bool Authentication::has_pw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authentication::set_has_pw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authentication::clear_has_pw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authentication::clear_pw() {
  if (pw_ != &::google::protobuf::internal::kEmptyString) {
    pw_->clear();
  }
  clear_has_pw();
}
inline const ::std::string& Authentication::pw() const {
  return *pw_;
}
inline void Authentication::set_pw(const ::std::string& value) {
  set_has_pw();
  if (pw_ == &::google::protobuf::internal::kEmptyString) {
    pw_ = new ::std::string;
  }
  pw_->assign(value);
}
inline void Authentication::set_pw(const char* value) {
  set_has_pw();
  if (pw_ == &::google::protobuf::internal::kEmptyString) {
    pw_ = new ::std::string;
  }
  pw_->assign(value);
}
inline void Authentication::set_pw(const char* value, size_t size) {
  set_has_pw();
  if (pw_ == &::google::protobuf::internal::kEmptyString) {
    pw_ = new ::std::string;
  }
  pw_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Authentication::mutable_pw() {
  set_has_pw();
  if (pw_ == &::google::protobuf::internal::kEmptyString) {
    pw_ = new ::std::string;
  }
  return pw_;
}
inline ::std::string* Authentication::release_pw() {
  clear_has_pw();
  if (pw_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pw_;
    pw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Authentication::set_allocated_pw(::std::string* pw) {
  if (pw_ != &::google::protobuf::internal::kEmptyString) {
    delete pw_;
  }
  if (pw) {
    set_has_pw();
    pw_ = pw;
  } else {
    clear_has_pw();
    pw_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VideoRequest

// required string ip = 1;
inline bool VideoRequest::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoRequest::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoRequest::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoRequest::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& VideoRequest::ip() const {
  return *ip_;
}
inline void VideoRequest::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void VideoRequest::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void VideoRequest::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoRequest::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* VideoRequest::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VideoRequest::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 2;
inline bool VideoRequest::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoRequest::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoRequest::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoRequest::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 VideoRequest::port() const {
  return port_;
}
inline void VideoRequest::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional int32 bitrate = 3;
inline bool VideoRequest::has_bitrate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoRequest::set_has_bitrate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoRequest::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoRequest::clear_bitrate() {
  bitrate_ = 0;
  clear_has_bitrate();
}
inline ::google::protobuf::int32 VideoRequest::bitrate() const {
  return bitrate_;
}
inline void VideoRequest::set_bitrate(::google::protobuf::int32 value) {
  set_has_bitrate();
  bitrate_ = value;
}

// -------------------------------------------------------------------

// WebRTCMessage

// required .svmp.WebRTCMessage.WebRTCType type = 1;
inline bool WebRTCMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebRTCMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebRTCMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebRTCMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::svmp::WebRTCMessage_WebRTCType WebRTCMessage::type() const {
  return static_cast< ::svmp::WebRTCMessage_WebRTCType >(type_);
}
inline void WebRTCMessage::set_type(::svmp::WebRTCMessage_WebRTCType value) {
  assert(::svmp::WebRTCMessage_WebRTCType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string sdp = 2;
inline bool WebRTCMessage::has_sdp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebRTCMessage::set_has_sdp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebRTCMessage::clear_has_sdp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebRTCMessage::clear_sdp() {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    sdp_->clear();
  }
  clear_has_sdp();
}
inline const ::std::string& WebRTCMessage::sdp() const {
  return *sdp_;
}
inline void WebRTCMessage::set_sdp(const ::std::string& value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void WebRTCMessage::set_sdp(const char* value) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(value);
}
inline void WebRTCMessage::set_sdp(const char* value, size_t size) {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  sdp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebRTCMessage::mutable_sdp() {
  set_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    sdp_ = new ::std::string;
  }
  return sdp_;
}
inline ::std::string* WebRTCMessage::release_sdp() {
  clear_has_sdp();
  if (sdp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdp_;
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebRTCMessage::set_allocated_sdp(::std::string* sdp) {
  if (sdp_ != &::google::protobuf::internal::kEmptyString) {
    delete sdp_;
  }
  if (sdp) {
    set_has_sdp();
    sdp_ = sdp;
  } else {
    clear_has_sdp();
    sdp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string id = 3;
inline bool WebRTCMessage::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WebRTCMessage::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WebRTCMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WebRTCMessage::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& WebRTCMessage::id() const {
  return *id_;
}
inline void WebRTCMessage::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void WebRTCMessage::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void WebRTCMessage::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebRTCMessage::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* WebRTCMessage::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebRTCMessage::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 labal = 4;
inline bool WebRTCMessage::has_labal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WebRTCMessage::set_has_labal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WebRTCMessage::clear_has_labal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WebRTCMessage::clear_labal() {
  labal_ = 0;
  clear_has_labal();
}
inline ::google::protobuf::int32 WebRTCMessage::labal() const {
  return labal_;
}
inline void WebRTCMessage::set_labal(::google::protobuf::int32 value) {
  set_has_labal();
  labal_ = value;
}

// optional string candidate = 5;
inline bool WebRTCMessage::has_candidate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WebRTCMessage::set_has_candidate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WebRTCMessage::clear_has_candidate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WebRTCMessage::clear_candidate() {
  if (candidate_ != &::google::protobuf::internal::kEmptyString) {
    candidate_->clear();
  }
  clear_has_candidate();
}
inline const ::std::string& WebRTCMessage::candidate() const {
  return *candidate_;
}
inline void WebRTCMessage::set_candidate(const ::std::string& value) {
  set_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    candidate_ = new ::std::string;
  }
  candidate_->assign(value);
}
inline void WebRTCMessage::set_candidate(const char* value) {
  set_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    candidate_ = new ::std::string;
  }
  candidate_->assign(value);
}
inline void WebRTCMessage::set_candidate(const char* value, size_t size) {
  set_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    candidate_ = new ::std::string;
  }
  candidate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebRTCMessage::mutable_candidate() {
  set_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    candidate_ = new ::std::string;
  }
  return candidate_;
}
inline ::std::string* WebRTCMessage::release_candidate() {
  clear_has_candidate();
  if (candidate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = candidate_;
    candidate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebRTCMessage::set_allocated_candidate(::std::string* candidate) {
  if (candidate_ != &::google::protobuf::internal::kEmptyString) {
    delete candidate_;
  }
  if (candidate) {
    set_has_candidate();
    candidate_ = candidate;
  } else {
    clear_has_candidate();
    candidate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace svmp

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_svmp_2eproto__INCLUDED
